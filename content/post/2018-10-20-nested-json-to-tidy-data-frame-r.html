---
title: Converting nested JSON to a tidy data frame with R
slug: nested-json-to-tidy-data-frame-r
date: "2018-10-20"
categories: []
tags:
 - r
 - json
 - dplyr
 - tidyr
 - nfl
banner: "img/nested-json-to-tidy-data-frame-r/json-everywhere-meme.png"
---



<p>In this “how-to” post, I want to detail an approach that others may find useful for converting nested (nasty!) json to a <a href="http://r4ds.had.co.nz/tidy-data.html">tidy</a> (nice!) <code>data.frame</code>/<code>tibble</code> that is should be much easier to work with. <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>For this demonstration, I’ll start out by scraping <a href="https://www.nfl.com/">National Football League</a> (NFL) 2018 regular season week 1 score data from <a href="http://www.espn.com/">ESPN</a>, which involves lots of nested data in its raw form. <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p>Then, I’ll work towards getting the data in a workable format (a <code>data.frame</code>!). (This is the crux of what I want to show.) Finally, I’ll filter and wrangle the data to generate a final, presentable format.</p>
<p>Even if one does not care for sports and knows nothing about the NFL, I believe that the techniques that I demonstrate are generalizable to a broad set of JSON-related “problems”.</p>
<div id="getting-the-data" class="section level2">
<h2>Getting the data</h2>
<p>Let’s being with importing the package(s) that we’ll need.</p>
<p>Next, we’ll create a variable for the url from which we will get the data. The url here will request the scores for week 1 of the 2018 NFL season from <a href="https://gist.github.com/akeaswaran/b48b02f1c94f873c6655e7129910fc3b">ESPN’s “secret” API</a>. <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<pre class="r"><code>url &lt;- &quot;http://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?&amp;dates=2018&amp;seasontype=2&amp;week=1&quot;</code></pre>
<p>And now, the actual HTTP <code>GET</code> request for the data (using the <a href="https://cran.r-project.org/web/packages/httr/index.html"><code>{httr}</code></a> package’s appropriately named <code>GET()</code> function).</p>
<pre class="r"><code>resp &lt;- httr::GET(url)
resp</code></pre>
<pre><code>## Response [http://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?&amp;dates=2018&amp;seasontype=2&amp;week=1]
##   Date: 2018-10-14 18:05
##   Status: 200
##   Content-Type: application/json;charset=UTF-8
##   Size: 185 kB</code></pre>
<p>Everything seems to be going well. However, after using another handy <code>{httr}</code> function—<code>content()</code>—to extract the data, we see that the data is an nasty nested format! (I only print out some of the top-level elements to avoid cluttering the page.)</p>
<pre class="r"><code>cont_raw &lt;- httr::content(resp)
str(cont_raw, max.level = 3, list.len = 4)</code></pre>
<pre><code>## List of 4
##  $ leagues:List of 1
##   ..$ :List of 11
##   .. ..$ id                 : chr &quot;28&quot;
##   .. ..$ uid                : chr &quot;s:20~l:28&quot;
##   .. ..$ name               : chr &quot;National Football League&quot;
##   .. ..$ abbreviation       : chr &quot;NFL&quot;
##   .. .. [list output truncated]
##  $ season :List of 2
##   ..$ type: int 2
##   ..$ year: int 2018
##  $ week   :List of 1
##   ..$ number: int 1
##  $ events :List of 16
##   ..$ :List of 9
##   .. ..$ id          : chr &quot;401030710&quot;
##   .. ..$ uid         : chr &quot;s:20~l:28~e:401030710&quot;
##   .. ..$ date        : chr &quot;2018-09-07T00:55Z&quot;
##   .. ..$ name        : chr &quot;Atlanta Falcons at Philadelphia Eagles&quot;
##   .. .. [list output truncated]
##   ..$ :List of 9
##   .. ..$ id          : chr &quot;401030718&quot;
##   .. ..$ uid         : chr &quot;s:20~l:28~e:401030718&quot;
##   .. ..$ date        : chr &quot;2018-09-09T17:00Z&quot;
##   .. ..$ name        : chr &quot;Pittsburgh Steelers at Cleveland Browns&quot;
##   .. .. [list output truncated]
##   ..$ :List of 9
##   .. ..$ id          : chr &quot;401030717&quot;
##   .. ..$ uid         : chr &quot;s:20~l:28~e:401030717&quot;
##   .. ..$ date        : chr &quot;2018-09-09T17:00Z&quot;
##   .. ..$ name        : chr &quot;Cincinnati Bengals at Indianapolis Colts&quot;
##   .. .. [list output truncated]
##   ..$ :List of 9
##   .. ..$ id          : chr &quot;401030716&quot;
##   .. ..$ uid         : chr &quot;s:20~l:28~e:401030716&quot;
##   .. ..$ date        : chr &quot;2018-09-09T17:00Z&quot;
##   .. ..$ name        : chr &quot;Tennessee Titans at Miami Dolphins&quot;
##   .. .. [list output truncated]
##   .. [list output truncated]</code></pre>
</div>
<div id="parsing-the-data" class="section level2">
<h2>Parsing the data</h2>
<p>Given the nature of the data, we might hope that the <a href="https://cran.r-project.org/web/packages/jsonlite/index.html"><code>{jsonlite}</code></a> package will save us here. However, straightforward usage of it’s <code>fromJSON()</code> package only reduces the mess a bit.</p>
<pre class="r"><code>data_raw_ugly &lt;- jsonlite::fromJSON(rawToChar(resp$content))
glimpse(data_raw_ugly, max.level = 3, list.len = 4)</code></pre>
<pre><code>## List of 4
##  $ leagues:&#39;data.frame&#39;: 1 obs. of  11 variables:
##   ..$ id                 : chr &quot;28&quot;
##   ..$ uid                : chr &quot;s:20~l:28&quot;
##   ..$ name               : chr &quot;National Football League&quot;
##   ..$ abbreviation       : chr &quot;NFL&quot;
##   .. [list output truncated]
##  $ season :List of 2
##   ..$ type: int 2
##   ..$ year: int 2018
##  $ week   :List of 1
##   ..$ number: int 1
##  $ events :&#39;data.frame&#39;: 16 obs. of  9 variables:
##   ..$ id          : chr [1:16] &quot;401030710&quot; &quot;401030718&quot; &quot;401030717&quot; &quot;401030716&quot; ...
##   ..$ uid         : chr [1:16] &quot;s:20~l:28~e:401030710&quot; &quot;s:20~l:28~e:401030718&quot; &quot;s:20~l:28~e:401030717&quot; &quot;s:20~l:28~e:401030716&quot; ...
##   ..$ date        : chr [1:16] &quot;2018-09-07T00:55Z&quot; &quot;2018-09-09T17:00Z&quot; &quot;2018-09-09T17:00Z&quot; &quot;2018-09-09T17:00Z&quot; ...
##   ..$ name        : chr [1:16] &quot;Atlanta Falcons at Philadelphia Eagles&quot; &quot;Pittsburgh Steelers at Cleveland Browns&quot; &quot;Cincinnati Bengals at Indianapolis Colts&quot; &quot;Tennessee Titans at Miami Dolphins&quot; ...
##   .. [list output truncated]</code></pre>
<p>One could go on and try some other functions from the <code>{jsonlite}</code> package (or another JSON-related package), but, in my own attempts, I was unable to figure out a nice way of getting a <code>data.frame()</code>. (This is not to say that there is something wrong with the package—I simply could not figure out how to use it to get the result that I wanted.)</p>
<p>So, what to do now? Well, after some struggling, I stumbled upon the following solution to put me on the right path.</p>
<pre class="r"><code>data_raw &lt;- enframe(unlist(cont_raw))
data_raw</code></pre>
<pre><code>## # A tibble: 6,461 x 2
##    name                     value                   
##    &lt;chr&gt;                    &lt;chr&gt;                   
##  1 leagues.id               28                      
##  2 leagues.uid              s:20~l:28               
##  3 leagues.name             National Football League
##  4 leagues.abbreviation     NFL                     
##  5 leagues.slug             nfl                     
##  6 leagues.season.year      2018                    
##  7 leagues.season.startDate 2018-08-02T07:00Z       
##  8 leagues.season.endDate   2019-02-06T07:59Z       
##  9 leagues.season.type.id   2                       
## 10 leagues.season.type.type 2                       
## # ... with 6,451 more rows</code></pre>
<p>Combining <code>unlist()</code> and <code>tibble::enframe()</code>, we are able to get a (very) long data.frame without any nested elements! Note that the would-have-been-nested elements are joined by “.” in the “name” column, and the values associated with these elements are in the “value” column. (These are the default column names that <code>tibble::enframe()</code> assigns to the <code>tibble</code> that it creates from a list.)</p>
<p>While this <code>tibble</code> is still not in a tidy format—there are variables implicitly stored in the “name” column rather than in their own columns—it’s in a much more user-friendly format (in my opinion). (e.g. The variable <code>&quot;leagues.season.startDate&quot;</code> implicitly encodes three variables—<code>&quot;leagues&quot;</code>, <code>&quot;season&quot;</code>, and <code>&quot;startDate&quot;</code>—each deserving of their own column.)</p>
<p>Given the format of the implicit variable sin the “name” column, We can use <code>tidyr::separate()</code> to create columns for each.</p>
<pre class="r"><code>data_raw %&gt;% separate(name, into = c(paste0(&quot;x&quot;, 1:10)))</code></pre>
<pre><code>## Warning: Expected 10 pieces. Missing pieces filled with `NA` in 6461
## rows [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
## 20, ...].</code></pre>
<pre><code>## # A tibble: 6,461 x 11
##    x1     x2      x3    x4    x5    x6    x7    x8    x9    x10   value   
##    &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   
##  1 leagu~ id      &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  28      
##  2 leagu~ uid     &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  s:20~l:~
##  3 leagu~ name    &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  Nationa~
##  4 leagu~ abbrev~ &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  NFL     
##  5 leagu~ slug    &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  nfl     
##  6 leagu~ season  year  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2018    
##  7 leagu~ season  star~ &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2018-08~
##  8 leagu~ season  endD~ &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2019-02~
##  9 leagu~ season  type  id    &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2       
## 10 leagu~ season  type  type  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2       
## # ... with 6,451 more rows</code></pre>
<p>We get a warning indicating when using <code>separate()</code> because we have “over-estimated” how many columns we will need to create. Note that, with my specification of (dummy) column names with the <code>into</code> argument, I guessed that there we would need 10 columns. Why 10? Because I expected that 10 would be more than I needed, and it’s better to over-estimate and remove the extra columns in a subsequent step than to under-estimate and lose data because there are not enough columns to put the “separated” data in.</p>
<p>We can get rid of the warning by providing an appropriate value for <code>separate()</code>’s <code>fill</code> argument. (Note that <code>&quot;warn&quot;</code> is the default value of the <code>fill</code> argument.)</p>
<pre class="r"><code>data_raw %&gt;% separate(name, into = c(paste0(&quot;x&quot;, 1:10)), fill = &quot;right&quot;)</code></pre>
<pre><code>## # A tibble: 6,461 x 11
##    x1     x2      x3    x4    x5    x6    x7    x8    x9    x10   value   
##    &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   
##  1 leagu~ id      &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  28      
##  2 leagu~ uid     &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  s:20~l:~
##  3 leagu~ name    &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  Nationa~
##  4 leagu~ abbrev~ &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  NFL     
##  5 leagu~ slug    &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  nfl     
##  6 leagu~ season  year  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2018    
##  7 leagu~ season  star~ &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2018-08~
##  8 leagu~ season  endD~ &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2019-02~
##  9 leagu~ season  type  id    &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2       
## 10 leagu~ season  type  type  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2       
## # ... with 6,451 more rows</code></pre>
<p>However, while this action gets rid of the warning, it does not actually resolve the underlying issue—specifying the correct number of columns to create with <code>separate()</code>. We can do that by identifying the <code>name</code> with the most number of <code>.</code>s.</p>
<pre class="r"><code>rgx_split &lt;- &quot;\\.&quot;
n_cols_max &lt;-
  data_raw %&gt;%
  pull(name) %&gt;% 
  str_split(rgx_split) %&gt;% 
  map_dbl(~length(.)) %&gt;% 
  max()
n_cols_max</code></pre>
<pre><code>## [1] 7</code></pre>
<p>With this number (7) identified, we can now choose the “correct” number of columns to create with <code>separate()</code>. Note that we’ll still be left with lots of <code>NA</code> values (corresponding to rows that don’t have the maximum number of variables). This is expected.</p>
<pre class="r"><code>nms_sep &lt;- paste0(&quot;name&quot;, 1:n_cols_max)
data_sep &lt;-
  data_raw %&gt;% 
  separate(name, into = nms_sep, sep = rgx_split, fill = &quot;right&quot;)
data_sep</code></pre>
<pre><code>## # A tibble: 6,461 x 8
##    name1   name2      name3    name4 name5 name6 name7 value              
##    &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;              
##  1 leagues id         &lt;NA&gt;     &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  28                 
##  2 leagues uid        &lt;NA&gt;     &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  s:20~l:28          
##  3 leagues name       &lt;NA&gt;     &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  National Football ~
##  4 leagues abbreviat~ &lt;NA&gt;     &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  NFL                
##  5 leagues slug       &lt;NA&gt;     &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  nfl                
##  6 leagues season     year     &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2018               
##  7 leagues season     startDa~ &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2018-08-02T07:00Z  
##  8 leagues season     endDate  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2019-02-06T07:59Z  
##  9 leagues season     type     id    &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2                  
## 10 leagues season     type     type  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2                  
## # ... with 6,451 more rows</code></pre>
<p>By my interpretation, this <code>data_sep</code> variable is in tidy format. Of course, it has</p>
</div>
<div id="post-processing-the-data" class="section level2">
<h2>“Post-processing” the data</h2>
<p>Getting the raw data in the format that <code>data_sep</code> is what I primarily wanted to show. Nonetheless, there’s more to the story! (Reminder: We’re seeking to get the scores from the 16 games in week 1 of the NFL’s 2018 regular season.) How can we work with the <code>NA</code>s to get a final format that is actually presentable?</p>
<p>We continue by filter the <code>tibble</code> for only the rows that we will need.</p>
<pre class="r"><code>data_filt &lt;-
  data_sep %&gt;%
  filter(
    (
      name1 == &quot;events&quot; &amp;
        name2 == &quot;shortName&quot;
    ) |
      (
        name1 == &quot;events&quot; &amp;
          name2 == &quot;competitions&quot; &amp;
          name3 == &quot;date&quot;
      ) | (
        name1 == &quot;events&quot; &amp;
          name2 == &quot;competitions&quot; &amp;
          name3 == &quot;status&quot; &amp;
          name4 == &quot;type&quot; &amp;
          name5 == &quot;name&quot;
      ) |
      (
        name1 == &quot;events&quot; &amp;
          name2 == &quot;competitions&quot; &amp;
          name3 == &quot;competitors&quot; &amp;
          name4 == &quot;score&quot;
      )
  )
data_filt</code></pre>
<pre><code>## # A tibble: 80 x 8
##    name1  name2        name3      name4 name5 name6 name7 value           
##    &lt;chr&gt;  &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;           
##  1 events shortName    &lt;NA&gt;       &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  ATL @ PHI       
##  2 events competitions date       &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2018-09-07T00:5~
##  3 events competitions competito~ score &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  18              
##  4 events competitions competito~ score &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  12              
##  5 events competitions status     type  name  &lt;NA&gt;  &lt;NA&gt;  STATUS_FINAL    
##  6 events shortName    &lt;NA&gt;       &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  PIT @ CLE       
##  7 events competitions date       &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  2018-09-09T17:0~
##  8 events competitions competito~ score &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  21              
##  9 events competitions competito~ score &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  21              
## 10 events competitions status     type  name  &lt;NA&gt;  &lt;NA&gt;  STATUS_FINAL    
## # ... with 70 more rows</code></pre>
<p>Next, we’ll create appropriately named columns for the values that we filtered for in the step above. <a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<pre class="r"><code>data_clean1 &lt;-
  data_filt %&gt;%
  select(name3, name4, name5, value) %&gt;%
  mutate(status = if_else(name5 == &quot;name&quot;, value, NA_character_)) %&gt;%
  mutate(isscore = if_else(name4 == &quot;score&quot;, TRUE, FALSE)) %&gt;%
  mutate(datetime = if_else(
    name3 == &quot;date&quot;,
    str_replace_all(value, &quot;\\s?T\\s?&quot;, &quot; &quot;) %&gt;% str_replace(&quot;Z$&quot;, &quot;&quot;),
    NA_character_
  )) %&gt;%
  mutate(gm = if_else(
    is.na(isscore) &amp;
      is.na(datetime) &amp; is.na(status),
    value,
    NA_character_
  ))
data_clean1</code></pre>
<pre><code>## # A tibble: 80 x 8
##    name3    name4 name5 value       status    isscore datetime     gm     
##    &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;     &lt;lgl&gt;   &lt;chr&gt;        &lt;chr&gt;  
##  1 &lt;NA&gt;     &lt;NA&gt;  &lt;NA&gt;  ATL @ PHI   &lt;NA&gt;      NA      &lt;NA&gt;         ATL @ ~
##  2 date     &lt;NA&gt;  &lt;NA&gt;  2018-09-07~ &lt;NA&gt;      NA      2018-09-07 ~ &lt;NA&gt;   
##  3 competi~ score &lt;NA&gt;  18          &lt;NA&gt;      TRUE    &lt;NA&gt;         &lt;NA&gt;   
##  4 competi~ score &lt;NA&gt;  12          &lt;NA&gt;      TRUE    &lt;NA&gt;         &lt;NA&gt;   
##  5 status   type  name  STATUS_FIN~ STATUS_F~ FALSE   &lt;NA&gt;         &lt;NA&gt;   
##  6 &lt;NA&gt;     &lt;NA&gt;  &lt;NA&gt;  PIT @ CLE   &lt;NA&gt;      NA      &lt;NA&gt;         PIT @ ~
##  7 date     &lt;NA&gt;  &lt;NA&gt;  2018-09-09~ &lt;NA&gt;      NA      2018-09-09 ~ &lt;NA&gt;   
##  8 competi~ score &lt;NA&gt;  21          &lt;NA&gt;      TRUE    &lt;NA&gt;         &lt;NA&gt;   
##  9 competi~ score &lt;NA&gt;  21          &lt;NA&gt;      TRUE    &lt;NA&gt;         &lt;NA&gt;   
## 10 status   type  name  STATUS_FIN~ STATUS_F~ FALSE   &lt;NA&gt;         &lt;NA&gt;   
## # ... with 70 more rows</code></pre>
<p>With these columns created, we can use <code>tidyr::fill()</code> and <code>dplyr::filter()</code> in a strategic manner to get rid of all the <code>NA</code>s cluttering our <code>tibble</code>. Additionally, we can drop the dummy <code>name</code> columns that we created with the <code>tidyr::separate()</code> call before.</p>
<pre class="r"><code>data_clean2 &lt;-
  data_clean1 %&gt;% 
  fill(status, .direction = &quot;up&quot;) %&gt;%
  filter(status == &quot;STATUS_FINAL&quot;) %&gt;%
  fill(gm, .direction = &quot;down&quot;) %&gt;%
  fill(datetime, .direction = &quot;down&quot;) %&gt;%
  filter(name3 == &quot;competitors&quot;) %&gt;% 
  select(-matches(&quot;name[0-9]&quot;))
data_clean2</code></pre>
<pre><code>## # A tibble: 32 x 5
##    value status       isscore datetime         gm       
##    &lt;chr&gt; &lt;chr&gt;        &lt;lgl&gt;   &lt;chr&gt;            &lt;chr&gt;    
##  1 18    STATUS_FINAL TRUE    2018-09-07 00:55 ATL @ PHI
##  2 12    STATUS_FINAL TRUE    2018-09-07 00:55 ATL @ PHI
##  3 21    STATUS_FINAL TRUE    2018-09-09 17:00 PIT @ CLE
##  4 21    STATUS_FINAL TRUE    2018-09-09 17:00 PIT @ CLE
##  5 23    STATUS_FINAL TRUE    2018-09-09 17:00 CIN @ IND
##  6 34    STATUS_FINAL TRUE    2018-09-09 17:00 CIN @ IND
##  7 27    STATUS_FINAL TRUE    2018-09-09 17:00 TEN @ MIA
##  8 20    STATUS_FINAL TRUE    2018-09-09 17:00 TEN @ MIA
##  9 24    STATUS_FINAL TRUE    2018-09-09 17:00 SF @ MIN 
## 10 16    STATUS_FINAL TRUE    2018-09-09 17:00 SF @ MIN 
## # ... with 22 more rows</code></pre>
<p>Finally, we can use a chain of <a href="https://cran.r-project.org/web/packages/dplyr/index.html"><code>{dplyr}</code></a> actions to get a pretty output. I should note that it is likely that everything up to this point would have an analogous action no matter what the data set is that you are working with. However, these final actions are unique to this specific data.</p>
<pre class="r"><code>data_clean3 &lt;-
  data_clean2 %&gt;% 
  group_by(gm) %&gt;%
  mutate(rn = row_number()) %&gt;%
  ungroup() %&gt;%
  mutate(tm_dir = if_else(rn == 1, &quot;pts_home&quot;, &quot;pts_away&quot;)) %&gt;%
  select(datetime, gm, tm_dir, value) %&gt;%
  spread(tm_dir, value) %&gt;%
  separate(gm, into = c(&quot;tm_away&quot;, &quot;tm_home&quot;), sep = &quot;(\\s+\\@\\s+)|(\\s+vs.*\\s+)&quot;) %&gt;% 
  mutate_at(vars(matches(&quot;pts&quot;)), funs(as.integer)) %&gt;%
  mutate(date = datetime %&gt;% str_remove(&quot;\\s.*$&quot;) %&gt;% lubridate::ymd()) %&gt;%
  mutate(time = datetime %&gt;% lubridate::ymd_hm()) %&gt;%
  select(date, time, tm_home, tm_away, pts_home, pts_away)
data_clean3</code></pre>
<pre><code>## # A tibble: 16 x 6
##    date       time                tm_home tm_away pts_home pts_away
##    &lt;date&gt;     &lt;dttm&gt;              &lt;chr&gt;   &lt;chr&gt;      &lt;int&gt;    &lt;int&gt;
##  1 2018-09-07 2018-09-07 00:55:00 PHI     ATL           18       12
##  2 2018-09-09 2018-09-09 17:00:00 BAL     BUF           47        3
##  3 2018-09-09 2018-09-09 17:00:00 IND     CIN           23       34
##  4 2018-09-09 2018-09-09 17:00:00 NE      HOU           27       20
##  5 2018-09-09 2018-09-09 17:00:00 NYG     JAX           15       20
##  6 2018-09-09 2018-09-09 17:00:00 CLE     PIT           21       21
##  7 2018-09-09 2018-09-09 17:00:00 MIN     SF            24       16
##  8 2018-09-09 2018-09-09 17:00:00 NO      TB            40       48
##  9 2018-09-09 2018-09-09 17:00:00 MIA     TEN           27       20
## 10 2018-09-09 2018-09-09 20:05:00 LAC     KC            28       38
## 11 2018-09-09 2018-09-09 20:25:00 CAR     DAL           16        8
## 12 2018-09-09 2018-09-09 20:25:00 DEN     SEA           27       24
## 13 2018-09-09 2018-09-09 20:25:00 ARI     WSH            6       24
## 14 2018-09-10 2018-09-10 00:20:00 GB      CHI           24       23
## 15 2018-09-10 2018-09-10 23:10:00 DET     NYJ           17       48
## 16 2018-09-11 2018-09-11 02:20:00 OAK     LAR           13       33</code></pre>
<p>And there we have it! A nice, tidy <code>tibble</code> with the scores of the first week of regular season games in the 2018 NFL regular season.</p>
</div>
<div id="sign-off" class="section level2">
<h2>Sign-off</h2>
<p>Hopefully someone out there will find the technique(s) shown in this post to be useful for an endeavor of their own.</p>
<p>Personally, I find web scraping to be fascinating, so I doubt this will be the last time I write about something of this nature.</p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I use <code>data.frame</code> and <code>tibble</code> interchangeably. See <a href="http://r4ds.had.co.nz/tibbles.html">this chapter</a> of the <a href="http://r4ds.had.co.nz/"><strong><em>R for Data Science</em></strong></a> for more details about the differences/similarities between the two.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>(See the webpage here: <a href="http://www.espn.com/nfl/scoreboard/_/year/2018/seasontype/2/week/1" class="uri">http://www.espn.com/nfl/scoreboard/_/year/2018/seasontype/2/week/1</a>. Note that we won’t be scraping the html, but, instead, the underlying JSON from which the html is generated.)<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>I say that it’s a secret because it’s API documentation is out of date.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>As a note to the reader, I don’t recommend suffixing variable names with numbers as I do in the next couple of step (i.e. variables suffixed with <code>1</code>, <code>2</code>, …) (It’s ugly!) In practice, you might do this during your exploratory phase of data scraping/analysis, but you should come up with more informative names and combine actions in a logical manner for your final script/package (in my opinion).<a href="#fnref4">↩</a></p></li>
</ol>
</div>
