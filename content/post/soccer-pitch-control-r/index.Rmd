---
title: Creating a Soccer Pitch Control Model with R
draft: true
date: '2020-09-28'
categories:
  - r
tags:
  - r
  - soccer
image:
  caption: ''
  focal_point: ''
  preview_only: true
header:
  caption: ''
  image: 'featured.jpg'
---

```{r setup, include=F, echo=F, cache=F}
# .dir_proj <- here::here('content', 'post', 'variable-importance-compare')
# .dir_output <- file.path(.dir_proj, 'output')
# knitr::opts_knit$set(root.dir = here::here())
knitr::opts_chunk$set(
  include = FALSE,
  echo = FALSE,
  cache = TRUE,
  cache.lazy = FALSE,
  fig.show = 'hide',
  fig.align = 'center',
  fig.width = 8,
  fig.asp = 0.75,
  warning = FALSE,
  message = FALSE
)
```
```{r all-r-code-together, include=F, echo=F, eval=T}
library(tidyverse)

get_default_pc_params <- function(time_to_control_veto = 3) {
  params <-
    list(
      max_player_accel = 7,
      max_player_speed = 5,
      reaction_time = 0.7,
      tti_sigma = 0.45,
      kappa_def = 1,
      lambda_att = 4.3,
      average_ball_speed = 15,
      int_dt = 0.04,
      max_int_time = 10,
      iter_min = 5,
      model_converge_tol = 0.01
    )
  params$lambda_def = 4.3 * params[['kappa_def']]
  params$lambda_gk = 3.0 * params[['lambda_def']]
  params$time_to_control_att = time_to_control_veto * log(10) * sqrt(3) * params[['tti_sigma']] * pi * (1 / params[['lambda_att']])
  params$time_to_control_def = time_to_control_veto * log(10) * sqrt(3) * params[['tti_sigma']] * pi * (1 / params[['lambda_def']])
  params
}

# class ----
new_player <-
  function(player_id = integer(),
           is_gk = logical(),
           side = character(),
           is_attack = logical(),
           tti = double(),
           in_frame = logical(),
           start_frame = integer(),
           x = double(),
           y = double(),
           x_v = double(),
           y_v = double(),
           vmax = double(),
           reaction_time = double(),
           tti_sigma = double(),
           lambda_att = double(),
           lambda_def = double()) {

    # I like using quotes for the names of list elements because they technically don't exist in the list before hand. Quotes implicitly imply that we are creating something new.
    res <-
      vctrs::new_rcrd(
        list(
          'player_id' = player_id,
          'is_gk' = is_gk,
          'side' = side,
          'is_attack' = is_attack,
          'tti' = tti,
          'in_frame' = in_frame,
          'name' = sprintf('%s_%s', side, player_id),
          'start_frame' = start_frame,
          'x' = x,
          'y' = y,
          'x_v' = x_v,
          'y_v' = y_v,
          'vmax' = vmax,
          'reaction_time' = reaction_time,
          'tti_sigma' = tti_sigma,
          'lambda_att' = lambda_att,
          'lambda_def' = lambda_def,
          'ppcf' = 0
        ),
        class = 'player'
      )
    res
  }

validate_player <- function(player) {
  
  vctrs::vec_assert(vctrs::field(player, 'player_id'), integer())
  side <- vctrs::field(player, 'side')
  vctrs::vec_assert(side, character())
  .validate_side(side)
  vctrs::vec_assert(vctrs::field(player, 'is_attack'), logical())
  vctrs::vec_assert(vctrs::field(player, 'tti'), double())
  vctrs::vec_assert(vctrs::field(player, 'in_frame'), logical())
  vctrs::vec_assert(vctrs::field(player, 'start_frame'), integer())
  vctrs::vec_assert(vctrs::field(player, 'x'), double())
  vctrs::vec_assert(vctrs::field(player, 'y'), double())
  vctrs::vec_assert(vctrs::field(player, 'x_v'), double())
  vctrs::vec_assert(vctrs::field(player, 'y_v'), double())
  vctrs::vec_assert(vctrs::field(player, 'vmax'), double())
  vctrs::vec_assert(vctrs::field(player, 'reaction_time'), double())
  vctrs::vec_assert(vctrs::field(player, 'tti_sigma'), double())
  vctrs::vec_assert(vctrs::field(player, 'lambda_att'), double())
  vctrs::vec_assert(vctrs::field(player, 'lambda_def'), double())
  player
}

player <- 
  function(player_id,
           frame,
           events,
           tracking,
           params = get_default_pc_params()) {
    
    player_id <- as.integer(player_id)
    start_frame <- as.integer(start_frame)

    vctrs::vec_assert(params, list())
    nms_req <- c('max_player_speed', 'reaction_time', 'tti_sigma', 'lambda_att', 'lambda_def')
    assertthat::assert_that(all(nms_req %in% names(params)))
    # TODO: Implement checks for the data types of the columns. (Even though stronger checking is done in `new_player()`, the user may pass in a "malformed" params that has the required names but whose key-value pairs don't have the correct types.
    
    assertthat::assert_that(is.data.frame(events))
    nms_req <- c('start_frame', 'team')
    assertthat::assert_that(all(nms_req %in% names(events)))
    
    event <- events %>% filter(start_frame == !!frame)
    assertthat::assert_that(nrow(event) == 1L)
    
    assertthat::assert_that(is.data.frame(tracking))
    nms_req <- c('frame', 'player', 'side', 'x', 'y', 'x_v', 'y_v')
    assertthat::assert_that(all(nms_req %in% names(tracking)))
    
    frame <- tracking %>% filter(frame == !!frame, player == player_id)
    # browser()
    assertthat::assert_that(nrow(frame) == 1L)

    side <- frame[['side']]
    # .validate_side(side)
    
    gk_numbers <- tracking %>% pull_gk_numbers()
    # vctrs::vec_assert(gk_numbers, character()) # Probably overkill
    assertthat::assert_that(
      length(gk_numbers) == 2, 
      identical(sort(names(gk_numbers)), c('away', 'home'))
    )
    is_gk <- any(player_id %in% gk_numbers)
    
    x <- frame[['x']]
    y <- frame[['y']]
    player <-
      new_player(
        player_id = player_id,
        is_gk = is_gk,
        is_attack = side == tolower(event[['team']]),
        tti = -1,
        in_frame = !is.na(x) & !is.na(y),
        side = side,
        x = x,
        y = y,
        x_v = frame[['x_v']],
        y_v = frame[['y_v']],
        vmax = params[['max_player_speed']],
        reaction_time = params[['reaction_time']],
        tti_sigma = params[['tti_sigma']],
        lambda_att = params[['lambda_att']],
        lambda_def = params[['lambda_def']]
      )
    player <- validate_player(player)
    player
}

format.player <- function(x, ...) {
  suffix <- if(vctrs::field(x, 'in_frame')) {
    sprintf('located at `(%.2f, %.2f)` with velocity = `<%.1f, %.1f>`', vctrs::field(x, 'x'), vctrs::field(x, 'y'), vctrs::field(x, 'x_v'), vctrs::field(x, 'y_v'))
  } else {
    'not on the pitch'
  }
  prefix <- sprintf('`player_id = %s`%s on %s team (%s) is ', vctrs::field(x, 'player_id'), ifelse(vctrs::field(x, 'is_gk'), ' (goalkeeper)', ''), vctrs::field(x, 'side'), ifelse(vctrs::field(x, 'is_attack'), 'attacking', 'defending'))
  msg <- paste0(prefix, suffix)
  cat(msg)
}

# .norm <- function(x1, x2, y1, y2) {
#   res <- sqrt((x2 - x1)^2 + (y2 - y1)^2)
#   res <- matrix(c(x1, y1, x2, y2), nrow = 2, byrow = TRUE)
#   res
# }

.norm <- function(x1, x2, y1, y2) {
  m <- matrix(c(x1, y1)) - matrix(c(x2, y2))
  res <- sqrt(sum(m^2))
  res
}

.tti.player <- function(x, rx2, ry2, ...) {
  ri <- vctrs::field(x, 'reaction_time')
  rx1 <- vctrs::field(x, 'x') + vctrs::field(x, 'x_v') * ri
  ry1 <- vctrs::field(x, 'y') + vctrs::field(x, 'y_v') * ri
  res <- ri + .norm(rx1, rx2, ry1, ry2) / vctrs::field(x, 'vmax')
  res
}

.p_intercept.player <- function(x, t, ...) {
  den_term <- (-pi / sqrt(3) / vctrs::field(x, 'tti_sigma')) * (t - vctrs::field(x, 'tti'))
  den <- 1 + exp(den_term)
  res <- 1 / den
  # assertthat::assert_that(res > 0, msg = sprintf('Probability to intercept (`%.2f`) cannot be < 0.', res))
  res
}

`.update_tti<-.player` <- function(x, value) {
  vctrs::field(x, 'tti') <- value
  x
}

# TODO!
# `.update_in_frame<-.player` <- function(x, value) {
#   vctrs::field(x, 'in_frame') <- value
#   x
# }

`.update_ppcf<-.player` <- function(x, value) {
  vctrs::field(x, 'ppcf') <- value
  x
}

.msg_cls_err <- function(x, f) {
  cls <- class(x)[1]
  sprintf('`%s()` doesn\'t know how to handle class `%s`!', f, cls) 
}

.tti.default <- function(x, ...) {
  stop(.msg_cls_err(x, '.tti'), call. = FALSE)
}

.p_intercept.default <- function(x, ...) {
  stop(.msg_cls_err(x, '.p_intercept'), call. = FALSE)
}

`.update_tti<-default` <- function(x, ...) {
  stop(.msg_cls_err(x, '.update_tti'), call. = FALSE)
}

`.update_ppcf<-default` <- function(x, ...) {
  stop(.msg_cls_err(x, '.update_ppcf'), call. = FALSE)
}

.tti <- function(x, ...) {
  UseMethod('.tti')
}

.p_intercept <- function(x, ...) {
  UseMethod('.p_intercept')
}

`.update_tti<-` <- function(x, ...) {
  UseMethod('.update_tti<-')
}

`.update_ppcf<-` <- function(x, ...) {
  UseMethod('.update_ppcf<-')
}

# calcs ----
f_assert_dppcf_dt <- function(dppcf_dt, i, is_attack = TRUE) {
  cnd <- dppcf_dt >= 0
  if(cnd) {
    return(invisible())
  }
  prefix <- ifelse(is_attack, 'attack', 'defend')
  msg <- sprintf('Incremental %sing player probability (`dppcf_dt = %.3f` at `i = %d`) must be >= 0', prefix, dppcf_dt, i)
  warning(msg, call. = FALSE)
}
f_assert_ppcf <- function(ppcf, i, is_attack = TRUE) {
  cnd <- ppcf >= 0 & ppcf <= 1
  if(cnd) {
    return(invisible())
  }
  prefix <- ifelse(is_attack, 'Attack', 'Defend')
  msg <- sprintf('%sing player probability (`ppcf = %.3f` at `i = %d`) must be >= 0 and <= 1', prefix, ppcf, i)
  warning(msg, call. = FALSE)
}

calculate_pc_at_target <-
  function(players,
           ball_x,
           ball_y,
           target_x = ball_x,
           target_y = ball_y,
           params = get_default_pc_params()) {

    ball_dist <- .norm(target_x, ball_x, target_y, ball_y)
    ball_time <- ball_dist / params[['average_ball_speed']]
    
    ps_att <- players %>% keep(~{field(.x, 'is_attack')})
    ps_def <- players %>% keep(~{!field(.x, 'is_attack')})

    f_update_tti <- function(v) {
      for(i in seq_along(v)) {
        value <- .tti(v[[i]], rx2 = target_x, ry2 = target_y)
        .update_tti(v[[i]]) <- value
      }
      invisible(v)
    }
    
    ps_att <- ps_att %>% f_update_tti()
    ps_att
    ps_def <- ps_def %>% f_update_tti()
    ps_def
    
    f_tau_min <- function(v) {
      res <- v %>% map_dbl(~field(..1, 'tti')) %>% min(na.rm = TRUE)
      res
    }
    
    tau_min_att <- ps_att %>% f_tau_min()
    tau_min_def <- ps_def %>% f_tau_min()
    
    t_def <- params[['time_to_control_def']]
    is_gt <- ifelse(tau_min_att - max(ball_time, tau_min_def) >= t_def, TRUE, FALSE)
    if(is_gt) {
      # message('`ppcf_def = 1` automatically because no defenders are sufficiently close.')
      res <- list('ppcf_att' = 0, 'ppcf_def' = 1)
      return(res)
    }
    
    t_att <- params[['time_to_control_att']]
    is_gt <- ifelse(tau_min_def - max(ball_time, tau_min_att) >= t_att, TRUE, FALSE)
    if(is_gt) {
      # message('`ppcf_att = 1` automatically because no attackers are sufficiently close.')
      res <- list('ppcf_att' = 1, 'ppcf_def' = 0)
      return(res)
    }
    
    f_discard <- function(v, tau_min, t) {
      res <-
        v %>% 
        discard(~is.na(field(..1, 'x'))) %>% 
        discard(~(field(., 'tti') - tau_min) >= t)
      res
    }
    ps_att_filt <- ps_att %>% f_discard(tau_min = tau_min_att, t = t_att)
    ps_def_filt <- ps_def %>% f_discard(tau_min = tau_min_def, t = t_def)
    int_dt <- params[['int_dt']]
    
    dt_seq <- seq(ball_time - int_dt, ball_time + params[['max_int_time']], by = int_dt)
    n_seq <- dt_seq %>% length()
    ppcf_att <- rep(0, n_seq)
    ppcf_def <- rep(0, n_seq)
    p_tot <- 0
    i <- 2
    limit_hi <- 1 
    limit_lo <- 0
    
    while (((1 - p_tot) > params[['model_converge_tol']]) & (i < n_seq) & i < params[['iter_min']])) {
      t <- dt_seq[i]
      ii <- i - 1
      for(ip in seq_along(ps_att_filt)) {
        
        lhs <- 1 - ppcf_att[ii] - ppcf_def[ii]
        p <- ps_att_filt[[ip]]
        dppcf_dt <- lhs * .p_intercept(p, t) * field(p, 'lambda_att')
        
        value_ip <- dppcf_dt * int_dt
        
        f_assert_dppcf_dt(dppcf_dt, i = i, is_attack = TRUE)
        .update_ppcf(ps_att_filt[[ip]]) <- value_ip
        
        value_i <- ppcf_att[i] + field(ps_att_filt[[ip]], 'ppcf')
        
        if(value_i >= limit_hi) {
          value_i <- limit_hi
        } else if(value_i <= limit_lo) {
          value_i <- limit_lo
        }
        
        ppcf_att[i] <- value_i
      }
      
      for(ip in seq_along(ps_def_filt)) {
        
        lhs <- 1 - ppcf_att[ii] - ppcf_def[ii]
        p <- ps_def_filt[[ip]]
        dppcf_dt <- lhs * .p_intercept(p, t) * field(p, 'lambda_def')
        
        value_ip <- dppcf_dt * int_dt
        
        f_assert_dppcf_dt(dppcf_dt, i = i, is_attack = FALSE)
        .update_ppcf(ps_def_filt[[ip]]) <- value_ip
        
        value_i <- ppcf_def[i] + field(ps_def_filt[[ip]], 'ppcf')
        
        if(value_i >= limit_hi) {
          value_i <- limit_hi
        } else if(value_i <= limit_lo) {
          value_i <- limit_lo
        }
        
        ppcf_def[i] <- value_i
      }
      
      # "Normalize" to make sure the two sum up to 1.
      ppcf_i <- ppcf_att[i] + ppcf_def[i]
      ppcf_att[i] <- ppcf_att[i] / ppcf_i
      ppcf_def[i] <- ppcf_def[i] / ppcf_i

      p_tot <- ppcf_att[i] + ppcf_def[i]
      i <- i + 1
      
    }

    if(i >= n_seq) {
      warning(sprintf('Integration failed to converge: `p_tot = %.3f`', p_tot), call. = FALSE)
    }
    
    i_last <- i - 1
    f_assert_ppcf(ppcf_att[i_last], i, is_attack = TRUE)
    f_assert_ppcf(ppcf_def[i_last], i, is_attack = FALSE)
    
    i_seq <- 1:i_last
    res <-
      list(
        # 'i_last' = i_last,
        # 'p_tot' = p_tot,
        # 'ppcf_att_seq' = ppcf_att[i_seq],
        # 'ppcf_def_seq' = ppcf_def[i_seq],
        'ppcf_att' = ppcf_att[i_last], 
        'ppcf_def' = ppcf_def[i_last]
      )
    res
  }

do_calculate_pc_for_event <-
  function(tracking, events, event_id, params = get_default_pc_params(), epv_grid = import_epv_grid(), n_cell_x = 50L, n_cell_y = 50L) {
    events1 <- events %>% filter(event_id == !!event_id)
    start_frame <- events1[['start_frame']]
    tracking1 <- tracking %>% filter(frame == start_frame)
    
    players <-
      tracking1 %>%
      pull(player) %>%
      map(
        ~ player(
          player_id = .x,
          events = events1,
          tracking = tracking1,
          start_frame = start_frame,
          params = params
        )
      )
    players
    
    dims <- .get_dims_opta()
    dx <- dims[1] / n_cell_x
    dy <- dims[2] / n_cell_y
    
    grid_pc <-
      crossing(
        x = seq(0 + dx / 2, dims[1], length.out = n_cell_x),
        y = seq(0 + dy / 2, dims[2], length.out = n_cell_y)
      )
    
    ball_x <- tracking1[1, ][['ball_x']]
    ball_y <- tracking1[1, ][['ball_y']]

    do <- function() {
      res <-
        grid_pc %>% 
        mutate(
          res = 
            map2(x, y, 
                 ~calculate_pc_at_target(
                   players = players,
                   ball_x = ball_x,
                   ball_y = ball_y,
                   target_x = ..1,
                   target_y = ..2
                 )
            )
        ) %>% 
        mutate(
          ppcf_att = map_dbl(res, ~pluck(.x, 'ppcf_att')),
          ppcf_def = map_dbl(res, ~pluck(.x, 'ppcf_def'))
        ) %>% 
        # select(-res) %>% 
        arrange(x, y)
      res
    }
    
    pc <- do()
    pc
  }
```

# Intro

There's never been a better time to be involved in sports analytics. There is a wealth of open-sourced data and code (not to mention well-researched and public analysis) to digest and use. Both people working for teams and people just doing at as a hobby are publishing new and interesting analyses every day.


In particular, the [FriendsOfTracking (FOT)](https://www.youtube.com/channel/UCUBFJYcag8j2rm_9HkrrA7w) group(?), co-led by Professor and author [David Sumpter])(https://twitter.com/Soccermatics) [^1] have put together an awesome series of videos on YouTube discussing modern soccer[^2] analytics, along with a collection of repositories on GitHub sharing the code shown in videos.

[^1]: author of one of my favorite books __Soccermatics__


[Laurie Shaw](https://twitter.com/EightyFivePoint) has shared code that implements the [pitch control model](https://www.youtube.com/watch?v=X9PrwPyolyU) described in [William Spearman](https://twitter.com/the_spearman)'s paper ["Beyond Expected Goals"](http://www.sloansportsconference.com/wp-content/uploads/2018/02/2002.pdf) is interesting to me. The model is different than the one that I used [to create some animations on Twitter](). Those were based on the pitch control model described by [Javier Fernandez](https://twitter.com/JaviOnData) and [Luke Bornn](https://twitter.com/lukebornn) in their paper ["Wide Open Spaces"] ([code](https://www.robert-hickman.eu/post/fall_back_in_to_space/) courtesy of [Rob Hickman](https://twitter.com/robwhickman)). (Apologies for the onslaught of links!)

Now, I am not one for language wars---and, in fact, I use python almost daily---but I I thought it would be awesome to be able to plot Spearman's pitch control model directly with `{ggplot2}` and friends. Thus, I set out to convert Laurie's code to R, attempting to give it a "native" R feel while I was at it.

Most of the process of translating python to R was relatively uninteresting (slicing and dicing data frames is just part of data cleaning), so I won't detail them here. However, there was one part that was particularly interesting---the conversion of a python class object to R. In fact, this was actually the key part of the whole process of getting a working (and "correct") pitch control model.

<!-- I thought it would be a good testing ground for porting python code to R code in a "native" R fashion, with the added challenge of [object-orientated programming (OOP)](https://en.wikipedia.org/wiki/Object-oriented_programming). -->

## How

Below is a heavily stripped down version of Laurie's code, showing the "essence" of what we need to replicate. [^1] I'm using ellipses (`...`) in the python code to indicate where code has been removed.

[^1]: If you actually browse Laurie's code, you'll notice that I've changed some of the names of these functions, e.g. `tti()` here instead of `simple_time_to_intercept()` there, `tracking_df` instead of `team` there. Don't worry about that. I just wanted to make things as comparable as possible for the diligent reader, and I tried to make variable names that were either (or both) more succinct or more clear.

Let's make some notes and come back to these as we develop our R class.

1. We need a unique identifier: `player_id`. This is really just a "best practice" thing for object-oriented programming and makes sense given our context. For a sport, a unique identifier could just be the player's name, a combination of the team name and the player jersey number, a league unique identifier, etc.

2. A single-row data frame `frame` is passed to several of the methods, including the constructor `__init__`. This single row data frame is sourced from a much larger `tracking` data frame, with rows for every 0.04 second time interval in the game. (Each interval is called a "frame".)

3. The python code stores both the player's `position` and `velocity` as 2x1 arrays. This works well with the unpacking that is done in other places in Laurie's code. 

4. `tti`, short for "time to intercept (the ball)", uses the player's `position` and `velocity` to define the attribute `tti` (not to be confused with the method itself). Thus, `position` and `velocity` should be defined before `tti()` is ever called, as they are done in `__init__`.

5. `p_intercept`, short for "probability to intercept (the ball)" depends on the p
Unfortunately, I don't think it is quite as natural to store these x-y pairs of values in an R vector. You'll see 

```{python player-python, include=T, echo=F, eval=F}
class player(object):
    def __init__(self,player_id,frame):
        self.id = player_id
        # <...>
        self.get_position(frame)
        self.get_velocity(frame)
        
    def get_position(self,frame):
        self.position = np.array(frame[self.player_id + 'x', self.player_id + 'y'])
        # <...>
        
    def get_velocity(self,frame):
        self.velocity = np.array(frame[self.player_id + 'x_v', self.player_id + 'y_v'])
        # <...>
    
    def tti(self,final_position):
        reaction_position = self.position + self.velocity * <...>
        self.tti = <...> + np.linalg.norm(final_positon - reaction_position)/<...>
        # <...>

    def p_intercept(self,t):
        return <...> (t - self.tti)
        # <...>
      
```

Ok, on to the R code. We'll be using [S3](https://adv-r.hadley.nz/s3.html) and the [`{vctrs}` package](https://vctrs.r-lib.org/) to help create our `player` class. Again, I've omitted details with `<...>` (which actually is a valid token in R[^1])

[^1]: Yes, I know `...` is also a valid token in python, but it's not used as commonly as it is in R and it has very specific functionality.

First, we start with the constructor `new_player()`. 

```{r new_player, include=T, echo=F, eval=F}
new_player <-
  function(player_id = integer(),
           x = double(),
           y = double(),
           x_v = double(),
           y_v = double(),
           ...) {
    vctrs::new_rcrd(
      list(
        player_id = player_id,
        x = x,
        y = y,
        x_v = x,
        y_v = y,
        tti = -1, # dummy value
        ...
      ),
      class = 'player'
    )
  }
```

1. We have the `player_id` in the constructor.

2. We don't pass the data frame `tracking` here. We'll do it in our helper function. We might say that our constructor is "low-level", not intended for the user to call directly.

3. We split the position and velocity vectors into their individual x and y components, resulting in four total variables instead of two. I don't think an unnamed or named vector, nor a list or a matrix, are particularly compelling data types. None natively support unpacking (although vectors do have "broadcasting"  


Next, a validator function. It is good practice to check the values used to construct the class. (The python code did not have any validation like this, but I don't think it was ever expected to be extremely robust to any user input.)

```{r validate_player, include=T, echo=F, eval=F}
validate_player <- function(player) {
  vctrs::vec_assert(vctrs::field(player, 'player_id'), integer())
  vctrs::vec_assert(vctrs::field(player, 'x'), double())
  vctrs::vec_assert(vctrs::field(player, 'y'), double())
  vctrs::vec_assert(vctrs::field(player, 'tti'), double())
  # More validation ...
  player
}
```


Finally, a helper `player()` function, which is our "user-facing" function that we expect/want users to use to instantiate objects.


```{r player, include=T, echo=F, eval=F}
player <- 
  function(player_id, frame, tracking, ...) {
    
    player_id <- as.integer(player_id)
    frame <- as.integer(frame)

    assertthat::assert_that(is.data.frame(tracking))
    nms_req <- c('player_id', 'frame', 'x', 'y', 'x_v', 'y_v')
    assertthat::assert_that(all(nms_req %in% names(tracking)))
    
    # `!!` to make sure that we filter using the integer values, not the column itself.
    tracking_filt <- tracking %>% filter(player_id == !!player_id, frame == !!frame)
    assertthat::assert_that(nrow(tracking_filt) == 1L)
    
    player <-
      new_player(
        player_id = player_id,
        x = tracking_filt[['x']],
        y = tracking_filt[['y']],
        x_v = tracking_filt[['x_v']],
        y_v = tracking_filt[['y_v']],
        ...
      )
    player <- validate_player(player)
    player
  }
```

Note that:

+ We do coercion on `player_id` and `frame` to make sure that they are integers instead of doubles. This ensures that the new `player` instance passes our validation.
+ We pass in our entire `tracking` data frame (that has rows for every 0.04 second interval in the game), as well as the `frame` to slice out of it. (`player_id` is also used to filter `tracking`.) This makes it convenient for user to instantiate new `player` objects when operating on the `tracking` data frame. There is no need to extract the singular initial position and velocity components "manually"; instead, the helper function does it for the user.

Ok, so that is all fine and dandy, but how would we go about instantiating players in a normal workflow? Let's say that we want to calculate the pitch control for a single `frame` in the `tracking` data.


```{r data, include=F, echo=F, eval=T}
# Data comes from post-processed Metrica sample game 2 data. I'm using a single frame here. Coordinates have been transformed to be on Opta's 100x100 unit grid.
.event_id <- 823L
.frame <- 53027L
# The events data frame has an `end_frame` in the actual data set as well, hence the `start_` prefix for `frame`.
events1 <-
  tibble(
    event_id = .event_id,
    start_frame = .frame
  )

.ball_x <- 89.251
.ball_y <- 36.112
# `frame` would already be a column in the data frame in the original data set, but I've just removed it from the tribble (along with `ball_x` and `ball_y`) to make the tribble thinner.
tracking1 <-
  tibble::tribble(
     ~side, ~player_id,     ~x,     ~y,   ~x_v,   ~y_v,
    'home',         1L, 86.403, 57.897,  5.625, -5.861,
    'home',         2L, 90.569, 39.919,  1.429, -2.975,
    'home',         3L, 91.436, 34.291,   1.35,  3.521,
    'home',         4L, 87.993, 22.997,  0.957,  5.107,
    'home',         5L,  79.96, 36.311,  4.036,  1.764,
    'home',         6L,  78.28, 52.395,  3.707, -0.911,
    'home',         7L, 81.707, 25.492,  1.621,  2.239,
    'home',         8L, 72.437, 73.768,  1.921, -0.725,
    'home',         9L, 58.304, 37.277,  0.821, -1.132,
    'home',        10L, 56.848, 51.611,  0.857, -0.843,
    'home',        11L,  97.66, 47.477, -0.293,  0.918,
    'home',        12L,     NA,     NA,     NA,     NA,
    'home',        13L,     NA,     NA,     NA,     NA,
    'home',        14L,     NA,     NA,     NA,     NA,
    'away',        15L, 65.766, 15.929,  2.039,  1.254,
    'away',        16L, 54.231,  34.43,  2.125, -0.729,
    'away',        17L, 52.172, 57.135,  1.232,   -1.1,
    'away',        18L, 53.468, 78.232,  0.461,  -2.15,
    'away',        19L, 83.557, 23.396,  1.368,  4.664,
    'away',        20L, 68.541,  41.98,  2.793,  1.207,
    'away',        21L, 58.819, 58.089,  1.221, -1.139,
    'away',        22L,  75.67, 66.388,  3.482, -0.968,
    'away',        23L, 89.311, 36.268,  1.589,  4.239,
    'away',        24L, 90.368, 54.044,  2.754,  1.468,
    'away',        25L, 20.222, 53.147,  0.125, -0.314,
    'away',        26L,     NA,     NA,     NA,     NA
  ) %>% 
  mutate(frame = .frame, ball_x = .ball_x, ball_y = .ball_y)
```

```{r tracking1}
tracking1
```

```{r players-fake, include=T, echo=F, eval=F}
players <-
  10L:12L %>%
  map(~player(player_id = .x, frame = 53027L, tracking = tracking1))
players
```

```{r players-real, include=F, echo=T, eval=T}
players <-
  10L:12L %>%
  map(~player(player_id = .x, frame = .frame, tracking = tracking1, events = event1))
players
```

Note the following

## Aside

R's S3 framework is not a formal object-oriented programming framework (https://en.wikipedia.org/wiki/Object-oriented_programming) (not even close really). I didn't state these before, but note the following about S3.
  + It does not have a token to represent the instance of the class like `self` in python.
  + Also, it is not actually necessary to name our constructor to be prefixed with `new_`. This is just a convention that we force upon ourselves to make it more clear what we are doing.
  + We don't even need a constructor function at all to "use" S3. We could do something like `class(var) <- 'player'` to create a a `player` object. Of course, this is lazy and wouldn't work well, so we don't do that!
  
Ok

## The Cool Stuff


```{r pc-main, include=F, echo=F, eval=T}
# pc-main ---
require(tidyverse)
# Data comes from post-processed Metrica sample game 2 data. I'm using a single frame here. Coordinates have been transformed to be on Opta's 100x100 unit grid.
.event_id <- 823L
.start_frame <- 53027L
events1 <-
  tibble(
    event_id = .event_id,
    start_frame = .start_frame
  )

.ball_x <- 89.251
.ball_y <- 36.112
# `frame` would already be a column in the data frame in the original data set, but I've just removed it from the tribble (along with `ball_x` and `ball_y`) to make the tribble thinner.
tracking1 <-
  tibble::tribble(
     ~side, ~player,     ~x,     ~y,   ~x_v,   ~y_v,
    'home',      1L, 86.403, 57.897,  5.625, -5.861,
    'home',      2L, 90.569, 39.919,  1.429, -2.975,
    'home',      3L, 91.436, 34.291,   1.35,  3.521,
    'home',      4L, 87.993, 22.997,  0.957,  5.107,
    'home',      5L,  79.96, 36.311,  4.036,  1.764,
    'home',      6L,  78.28, 52.395,  3.707, -0.911,
    'home',      7L, 81.707, 25.492,  1.621,  2.239,
    'home',      8L, 72.437, 73.768,  1.921, -0.725,
    'home',      9L, 58.304, 37.277,  0.821, -1.132,
    'home',     10L, 56.848, 51.611,  0.857, -0.843,
    'home',     11L,  97.66, 47.477, -0.293,  0.918,
    'home',     12L,     NA,     NA,     NA,     NA,
    'home',     13L,     NA,     NA,     NA,     NA,
    'home',     14L,     NA,     NA,     NA,     NA,
    'away',     15L, 65.766, 15.929,  2.039,  1.254,
    'away',     16L, 54.231,  34.43,  2.125, -0.729,
    'away',     17L, 52.172, 57.135,  1.232,   -1.1,
    'away',     18L, 53.468, 78.232,  0.461,  -2.15,
    'away',     19L, 83.557, 23.396,  1.368,  4.664,
    'away',     20L, 68.541,  41.98,  2.793,  1.207,
    'away',     21L, 58.819, 58.089,  1.221, -1.139,
    'away',     22L,  75.67, 66.388,  3.482, -0.968,
    'away',     23L, 89.311, 36.268,  1.589,  4.239,
    'away',     24L, 90.368, 54.044,  2.754,  1.468,
    'away',     25L, 20.222, 53.147,  0.125, -0.314,
    'away',     26L,     NA,     NA,     NA,     NA
  ) %>% 
  mutate(frame = .start_frame, ball_x = .ball_x, ball_y = .ball_y)

pc <-
  do_calculate_pc_for_event(
    tracking = tracking1,
    events = events1,
    event_id = .event_id
  ) %>% 
  select(-pc)

pal <- colorRampPalette(c('red', 'white', 'blue'))(10)
viz <-
  pc %>% 
  ggplot() +
  aes(x = x, y = y, z = ppcf_att) +
  .pitch_gg() +
  geom_contour_filled(aes(fill = ..level.., color = ..level..), alpha = 0.7) +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal) +
  guides(fill = FALSE) +
  ggnewscale::new_scale_fill() +
  geom_point(
    data = tracking1,
    aes(fill = side),
    size = 3,
    color = 'black',
    shape = 21
  ) +
  scale_fill_manual(values = c('home' = 'red', 'away' = 'blue')) +
  geom_point(
    data = events1,
    aes(x = start_x, y = start_y),
    size = 1,
    fill = 'yellow',
    color = 'black',
    shape = 23
  )
viz
```
