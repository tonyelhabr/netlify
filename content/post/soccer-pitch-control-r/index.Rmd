---
title: Creating a Soccer Pitch Control Model with R
draft: true
date: '2020-09-28'
categories:
  - r
tags:
  - r
  - soccer
image:
  caption: ''
  focal_point: ''
  preview_only: true
header:
  caption: ''
  image: 'featured.jpg'
output:
  html_document:
    keep_md: yes
---

```{r setup, include=F, echo=F, cache=F}
# .dir_proj <- here::here('content', 'post', 'variable-importance-compare')
# .dir_output <- file.path(.dir_proj, 'output')
# knitr::opts_knit$set(root.dir = here::here())
# Apply Claus' workflow?
knitr::opts_chunk$set(
  include = FALSE,
  echo = FALSE,
  cache = TRUE,
  cache.lazy = FALSE,
  fig.show = 'hide',
  fig.align = 'center',
  fig.width = 8,
  fig.asp = 0.75,
  fig.retina = 2,
  warning = FALSE,
  message = FALSE
)
```

```{r player-helpers, include=F, echo=F, eval=T}
library(tidyverse)

.get_default_pc_params <- function(time_to_control_veto = 3) {
  params <-
    list(
      max_player_accel = 7,
      max_player_speed = 5,
      reaction_time = 0.7,
      tti_sigma = 0.45,
      kappa_def = 1,
      lambda_att = 4.3,
      average_ball_speed = 15,
      int_dt = 0.04,
      max_int_time = 10,
      iter_min = 5L,
      model_converge_tol = 0.01
    )
  params$lambda_def = 4.3 * params[['kappa_def']]
  params$lambda_gk = 3.0 * params[['lambda_def']]
  params$time_to_control_att = time_to_control_veto * log(10) * sqrt(3) * params[['tti_sigma']] * pi * (1 / params[['lambda_att']])
  params$time_to_control_def = time_to_control_veto * log(10) * sqrt(3) * params[['tti_sigma']] * pi * (1 / params[['lambda_def']])
  params
}

.get_dims_opta <- function() {
  # c(106, 68)
  c(100, 100)
}

.get_valid_sides <- function() {
  c('away', 'home')
}

.validate_side <- function(x = .get_valid_sides()) {
  match.arg(x)
}

# This may be useful outside of just being used in the `player` helper function.
pull_gk_ids <- memoise::memoise({
  function(tracking) {
    res <-
      tracking %>% 
      group_by(side) %>% 
      filter(frame == min(frame)) %>% 
      filter(abs(x) == max(abs(x), na.rm = TRUE)) %>% 
      ungroup() %>% 
      # This returns the player numbers as characters! Don't want that.
      pull(player_id, side)
    nms <- res %>% names()
    vals <- res %>% as.integer()
    res <- setNames(vals, nms)
    res
  }
})

.get_pitch <- function(pitch_fill = 'white', pitch_color = 'black', limits = FALSE) {
  ggsoccer::annotate_pitch(
    fill = pitch_fill, 
    colour = pitch_color,
    limits = limits,
    dimension = ggsoccer::pitch_opta
  )
}

.pitch_gg <- function(pitch = .get_pitch(), ...) {
  res <-
    list(
      ...,
      pitch,
      ggsoccer::theme_pitch(),
      theme(legend.position = 'none')
    )
  res
}
```

```{r player-class, include=F, echo=F, eval=T}
new_player <-
  function(player_id = integer(),
           is_gk = logical(),
           side = character(),
           is_attack = logical(),
           tti = double(),
           in_frame = logical(),
           x = double(),
           y = double(),
           x_v = double(),
           y_v = double(),
           vmax = double(),
           reaction_time = double(),
           tti_sigma = double(),
           lambda_att = double(),
           lambda_def = double()) {

    # I like using quotes for the names of list elements because they technically don't exist in the list before hand. Quotes implicitly imply that we are creating something new.
    player <-
      vctrs::new_rcrd(
        list(
          'player_id' = player_id,
          'is_gk' = is_gk,
          'side' = side,
          'is_attack' = is_attack,
          'tti' = tti,
          'in_frame' = in_frame,
          'name' = sprintf('%s_%s', side, player_id),
          'x' = x,
          'y' = y,
          'x_v' = x_v,
          'y_v' = y_v,
          'vmax' = vmax,
          'reaction_time' = reaction_time,
          'tti_sigma' = tti_sigma,
          'lambda_att' = lambda_att,
          'lambda_def' = lambda_def,
          'ppcf' = 0
        ),
        class = 'player'
      )
    player
  }

validate_player <- function(player) {
  
  vctrs::vec_assert(vctrs::field(player, 'player_id'), integer())
  side <- vctrs::field(player, 'side')
  vctrs::vec_assert(side, character())
  .validate_side(side)
  vctrs::vec_assert(vctrs::field(player, 'is_attack'), logical())
  vctrs::vec_assert(vctrs::field(player, 'tti'), double())
  vctrs::vec_assert(vctrs::field(player, 'in_frame'), logical())
  vctrs::vec_assert(vctrs::field(player, 'x'), double())
  vctrs::vec_assert(vctrs::field(player, 'y'), double())
  vctrs::vec_assert(vctrs::field(player, 'x_v'), double())
  vctrs::vec_assert(vctrs::field(player, 'y_v'), double())
  vctrs::vec_assert(vctrs::field(player, 'vmax'), double())
  vctrs::vec_assert(vctrs::field(player, 'reaction_time'), double())
  vctrs::vec_assert(vctrs::field(player, 'tti_sigma'), double())
  vctrs::vec_assert(vctrs::field(player, 'lambda_att'), double())
  vctrs::vec_assert(vctrs::field(player, 'lambda_def'), double())
  player
}

player <- 
  function(player_id,
           frame,
           events,
           tracking,
           params = .get_default_pc_params(),
           gk_ids = pull_gk_ids(tracking)) {
    

    player_id <- as.integer(player_id)
    frame <- as.integer(frame)

    vctrs::vec_assert(params, list())
    nms_req <- c('max_player_speed', 'reaction_time', 'tti_sigma', 'lambda_att', 'lambda_def')
    assertthat::assert_that(all(nms_req %in% names(params)))
    # TODO: Implement checks for the data types of the columns. (Even though stronger checking is done in `new_player()`, the user may pass in a "malformed" params that has the required names but whose key-value pairs don't have the correct types.
    
    assertthat::assert_that(is.data.frame(events))
    nms_req <- c('start_frame', 'side')
    assertthat::assert_that(all(nms_req %in% names(events)))
    
    event_filt <- events %>% filter(start_frame == !!frame)
    assertthat::assert_that(nrow(event_filt) == 1L)

    assertthat::assert_that(is.data.frame(tracking))
    nms_req <- c('frame', 'player_id', 'side', 'x', 'y', 'x_v', 'y_v')
    assertthat::assert_that(all(nms_req %in% names(tracking)))

    tracking_filt <- tracking %>% filter(frame == !!frame, player_id == !!player_id)
    assertthat::assert_that(nrow(tracking_filt) == 1L)

    side <- tracking_filt[['side']]

    assertthat::assert_that(
      length(gk_ids) == 2, 
      identical(sort(names(gk_ids)), c('away', 'home'))
    )
    is_gk <- any(player_id %in% gk_ids)
    
    x <- tracking_filt[['x']]
    y <- tracking_filt[['y']]
    player <-
      new_player(
        player_id = player_id,
        is_gk = is_gk,
        is_attack = side == event_filt[['side']],
        tti = -1,
        in_frame = !is.na(x) & !is.na(y),
        side = side,
        x = x,
        y = y,
        x_v = tracking_filt[['x_v']],
        y_v = tracking_filt[['y_v']],
        vmax = params[['max_player_speed']],
        reaction_time = params[['reaction_time']],
        tti_sigma = params[['tti_sigma']],
        lambda_att = params[['lambda_att']],
        lambda_def = params[['lambda_def']]
      )
    player <- validate_player(player)
    player
}
```

```{r player-print, include=F, echo=F, eval=T}
format.player <- function(player, ...) {
  if(vctrs::field(player, 'in_frame')) {
    suffix <- sprintf('with `position = (%.2f, %.2f)` and `velocity = <%.1f, %.1f>`', vctrs::field(player, 'player_id'), vctrs::field(player, 'y'), vctrs::field(player, 'x_v'), vctrs::field(player, 'y_v'))
  } else {
    suffix <- 'is not on the pitch'
  }
  prefix <- sprintf('`player_id = %s` ', vctrs::field(player, 'player_id'))
  msg <- sprintf('%s%s', prefix, suffix)
  paste(msg, sep = '\n')
}

obj_print_data.player <- function(player) {
  cat(format(player), sep = '\n')
}
```

```{r tti-real-hide, include=F, echo=F, eval=T}
# .norm <- function(x1, x2, y1, y2) {
#   res <- sqrt((x2 - x1)^2 + (y2 - y1)^2)
#   res <- matrix(c(x1, y1, x2, y2), nrow = 2, byrow = TRUE)
#   res
# }
.norm <- function(x1, x2, y1, y2) {
  m <- matrix(c(x1, y1)) - matrix(c(x2, y2))
  res <- sqrt(sum(m^2))
  res
}

get_tti.player <- function(player, x2, y2, ...) {
  ri <- vctrs::field(player, 'reaction_time')
  x1 <- vctrs::field(player, 'x') + vctrs::field(player, 'x_v') * ri
  y1 <- vctrs::field(player, 'y') + vctrs::field(player, 'y_v') * ri
  res <- ri + .norm(x1, x2, y1, y2) / vctrs::field(player, 'vmax')
  res
}
```

```{r tti-real-show, include=F, echo=F, eval=T}
.msg_cls_err <- function(player, f) {
  cls <- class(player)[1]
  sprintf('`%s()` doesn\'t know how to handle class `%s`!', f, cls) 
}

get_tti.default <- function(player, ...) {
  stop(.msg_cls_err(player, 'get_tti'), call. = FALSE)
}

get_tti <- function(player, ...) {
  UseMethod('get_tti')
}

`set_tti<-.player` <- function(player, value) {
  vctrs::field(player, 'tti') <- value
  player
}

`set_tti<-.default` <- function(player, ...) {
  stop(.msg_cls_err(player, 'set_tti'), call. = FALSE)
}

`set_tti<-` <- function(player, ...) {
  UseMethod('set_tti<-')
}
```

```{r p_intercept-real-hide}
get_p_intercept.player <- function(player, t, ...) {
  den_term <- (-pi / sqrt(3) / vctrs::field(player, 'tti_sigma')) * (t - vctrs::field(player, 'tti'))
  den <- 1 + exp(den_term)
  res <- 1 / den
  # assertthat::assert_that(res > 0, msg = sprintf('Probability to intercept (`%.2f`) cannot be < 0.', res))
  res
}
```

```{r p_intercept-real-show, include=F, echo=F, eval=T}
get_p_intercept.default <- function(player, ...) {
  stop(.msg_cls_err(player, 'get_p_intercept'), call. = FALSE)
}

get_p_intercept <- function(player, ...) {
  UseMethod('get_p_intercept')
}

`set_ppcf<-.player` <- function(player, value) {
  vctrs::field(player, 'p_intercept') <- value
  player
}

`set_p_intercept<-.default` <- function(player, ...) {
  stop(.msg_cls_err(player, 'set_p_intercept'), call. = FALSE)
}

`set_p_intercept<-` <- function(player, ...) {
  UseMethod('set_p_intercept<-')
}
```

```{r ppcf-real, include=F, echo=F, eval=T}
`set_ppcf<-.player` <- function(player, value) {
  vctrs::field(player, 'ppcf') <- value
  player
}

`set_ppcf<-.default` <- function(player, ...) {
  stop(.msg_cls_err(player, 'set_ppcf'), call. = FALSE)
}

`set_ppcf<-` <- function(player, ...) {
  UseMethod('set_ppcf<-')
}
```

```{r player-calcs, include=F, echo=F, eval=T}
f_assert_dppcf_dt <- function(dppcf_dt, i, is_attack = TRUE) {
  cnd <- dppcf_dt >= 0
  if(cnd) {
    return(invisible())
  }
  prefix <- ifelse(is_attack, 'attack', 'defend')
  msg <- sprintf('Incremental %sing player probability (`dppcf_dt = %.3f` at `i = %d`) must be >= 0', prefix, dppcf_dt, i)
  warning(msg, call. = FALSE)
}

f_assert_ppcf <- function(ppcf, i, is_attack = TRUE) {
  cnd <- ppcf >= 0 & ppcf <= 1
  if(cnd) {
    return(invisible())
  }
  prefix <- ifelse(is_attack, 'Attack', 'Defend')
  msg <- sprintf('%sing player probability (`ppcf = %.3f` at `i = %d`) must be >= 0 and <= 1', prefix, ppcf, i)
  warning(msg, call. = FALSE)
}

# `target_[xy]` will be equal to `ball_[xy]` when just calculating pitch control only at the ball.
# We will end up calculating pitch control for the entire pitch for a single frame.
calculate_pc_at_target <-
  function(players,
           ball_x,
           ball_y,
           target_x = ball_x,
           target_y = ball_y,
           params = .get_default_pc_params()) {

    ball_dist <- .norm(target_x, ball_x, target_y, ball_y)
    ball_time <- ball_dist / params[['average_ball_speed']]
    
    ps_att <- players %>% keep(~{vctrs::field(.x, 'is_attack')})
    ps_def <- players %>% keep(~{!vctrs::field(.x, 'is_attack')})

    f_update_tti <- function(v) {
      # Don't think `map` works for updating a value in place, so need to use a `for` loop (yikes!)
      for(i in seq_along(v)) {
        # browser()
        value <- get_tti(v[[i]], x2 = target_x, y2 = target_y)
        set_tti(v[[i]]) <- value
      }
      invisible(v)
    }
    
    ps_att <- ps_att %>% f_update_tti()
    ps_def <- ps_def %>% f_update_tti()
    
    f_tau_min <- function(v) {
      v %>% map_dbl(~vctrs::field(..1, 'tti')) %>% min(na.rm = TRUE)
    }
    
    tau_min_att <- ps_att %>% f_tau_min()
    tau_min_def <- ps_def %>% f_tau_min()
    
    t_def <- params[['time_to_control_def']]
    is_gt <- ifelse(tau_min_att - max(ball_time, tau_min_def) >= t_def, TRUE, FALSE)
    if(is_gt) {
      # message('`ppcf_def = 1` automatically because no defenders are sufficiently close.')
      res <- list('ppcf_att' = 0, 'ppcf_def' = 1)
      return(res)
    }
    
    t_att <- params[['time_to_control_att']]
    is_gt <- ifelse(tau_min_def - max(ball_time, tau_min_att) >= t_att, TRUE, FALSE)
    if(is_gt) {
      # message('`ppcf_att = 1` automatically because no attackers are sufficiently close.')
      res <- list('ppcf_att' = 1, 'ppcf_def' = 0)
      return(res)
    }
    
    f_discard <- function(v, tau_min, t) {
      res <-
        v %>% 
        discard(~is.na(vctrs::field(..1, 'x'))) %>% 
        discard(~(vctrs::field(., 'tti') - tau_min) >= t)
      res
    }
    ps_att_filt <- ps_att %>% f_discard(tau_min = tau_min_att, t = t_att)
    ps_def_filt <- ps_def %>% f_discard(tau_min = tau_min_def, t = t_def)
    int_dt <- params[['int_dt']]
    
    dt_seq <- seq(ball_time - int_dt, ball_time + params[['max_int_time']], by = int_dt)
    n_seq <- dt_seq %>% length()
    ppcf_att <- rep(0, n_seq)
    ppcf_def <- rep(0, n_seq)
    p_tot <- 0
    i <- 2
    limit_hi <- 1 
    limit_lo <- 0
    
    while (((1 - p_tot) > params[['model_converge_tol']]) & (i < n_seq) & i < params[['iter_min']]) {
      t <- dt_seq[i]
      ii <- i - 1
      for(ip in seq_along(ps_att_filt)) {
        
        lhs <- 1 - ppcf_att[ii] - ppcf_def[ii]
        p <- ps_att_filt[[ip]]
        dppcf_dt <- lhs * get_p_intercept(p, t) * vctrs::field(p, 'lambda_att')
        
        value_ip <- dppcf_dt * int_dt
        
        f_assert_dppcf_dt(dppcf_dt, i = i, is_attack = TRUE)
        set_ppcf(ps_att_filt[[ip]]) <- value_ip
        
        value_i <- ppcf_att[i] + vctrs::field(ps_att_filt[[ip]], 'ppcf')
        
        if(value_i >= limit_hi) {
          value_i <- limit_hi
        } else if(value_i <= limit_lo) {
          value_i <- limit_lo
        }
        
        ppcf_att[i] <- value_i
      }
      
      for(ip in seq_along(ps_def_filt)) {
        
        lhs <- 1 - ppcf_att[ii] - ppcf_def[ii]
        p <- ps_def_filt[[ip]]
        dppcf_dt <- lhs * get_p_intercept(p, t) * vctrs::field(p, 'lambda_def')
        
        value_ip <- dppcf_dt * int_dt
        
        f_assert_dppcf_dt(dppcf_dt, i = i, is_attack = FALSE)
        set_ppcf(ps_def_filt[[ip]]) <- value_ip
        
        value_i <- ppcf_def[i] + vctrs::field(ps_def_filt[[ip]], 'ppcf')
        
        if(value_i >= limit_hi) {
          value_i <- limit_hi
        } else if(value_i <= limit_lo) {
          value_i <- limit_lo
        }
        
        ppcf_def[i] <- value_i
      }
      
      # "Normalize" to make sure the two sum up to 1.
      ppcf_i <- ppcf_att[i] + ppcf_def[i]
      ppcf_att[i] <- ppcf_att[i] / ppcf_i
      ppcf_def[i] <- ppcf_def[i] / ppcf_i

      p_tot <- ppcf_att[i] + ppcf_def[i]
      i <- i + 1
      
    }

    if(i >= n_seq) {
      warning(sprintf('Integration failed to converge: `p_tot = %.3f`', p_tot), call. = FALSE)
    }
    
    i_last <- i - 1
    f_assert_ppcf(ppcf_att[i_last], i, is_attack = TRUE)
    f_assert_ppcf(ppcf_def[i_last], i, is_attack = FALSE)
    
    i_seq <- 1:i_last
    res <-
      list(
        'ppcf_att' = ppcf_att[i_last], 
        'ppcf_def' = ppcf_def[i_last]
      )
    res
  }

do_calculate_pc_for_event <-
  function(tracking,
           events,
           event_id,
           params = .get_default_pc_params(),
           n_cell_x = 50L,
           n_cell_y = 50L,
           dims = .get_dims_opta()) {
    
    events1 <- events %>% filter(event_id == !!event_id)
    start_frame <- events1[['start_frame']]
    tracking1 <- tracking %>% filter(frame == start_frame)
    
    players <-
      tracking1 %>%
      pull(player_id) %>%
      map(
        ~ player(
          player_id = .x,
          events = events1,
          tracking = tracking1,
          frame = start_frame,
          params = params
        )
      )
    players
    
    dx <- dims[1] / n_cell_x
    dy <- dims[2] / n_cell_y
    
    grid_pc <-
      crossing(
        x = seq(0 + dx / 2, dims[1], length.out = n_cell_x),
        y = seq(0 + dy / 2, dims[2], length.out = n_cell_y)
      )
    
    ball_x <- tracking1[1, ][['ball_x']]
    ball_y <- tracking1[1, ][['ball_y']]

    pc <-
      grid_pc %>% 
      mutate(
        res = 
          map2(x, y, 
               ~calculate_pc_at_target(
                 players = players,
                 ball_x = ball_x,
                 ball_y = ball_y,
                 target_x = ..1,
                 target_y = ..2
               )
          )
      ) %>% 
      mutate(
        ppcf_att = map_dbl(res, ~pluck(.x, 'ppcf_att')),
        ppcf_def = map_dbl(res, ~pluck(.x, 'ppcf_def'))
      ) %>% 
      select(-res) %>% 
      arrange(x, y)
    pc
  }
```

## Intro

There's never been a better time to be involved in sports analytics. There is a wealth of open-sourced data and code (not to mention well-researched and public analysis) to digest and use. Both people working for teams and people just doing at as a hobby are publishing new and interesting analyses every day.


In particular, the [FriendsOfTracking (FOT)](https://www.youtube.com/channel/UCUBFJYcag8j2rm_9HkrrA7w) group(?), co-led by Professor and author [David Sumpter])(https://twitter.com/Soccermatics) [^1] have put together an awesome series of videos on YouTube discussing modern soccer[^2] analytics, along with a collection of repositories on GitHub sharing the code shown in videos.

[^1]: author of one of my favorite books __Soccermatics__


[Laurie Shaw](https://twitter.com/EightyFivePoint) has shared code that implements the [pitch control model](https://www.youtube.com/watch?v=X9PrwPyolyU) described in [William Spearman](https://twitter.com/the_spearman)'s paper ["Beyond Expected Goals"](http://www.sloansportsconference.com/wp-content/uploads/2018/02/2002.pdf) is interesting to me. The model is different than the one that I used [to create some animations on Twitter](). Those were based on the pitch control model described by [Javier Fernandez](https://twitter.com/JaviOnData) and [Luke Bornn](https://twitter.com/lukebornn) in their paper ["Wide Open Spaces"] ([code](https://www.robert-hickman.eu/post/fall_back_in_to_space/) courtesy of [Rob Hickman](https://twitter.com/robwhickman)). (Apologies for the onslaught of links!)

Now, I am not one for language wars---and, in fact, I use python almost daily---but I I thought it would be awesome to be able to plot Spearman's pitch control model directly with `{ggplot2}` and friends. Thus, I set out to convert Laurie's code to R, attempting to give it a "native" R feel while I was at it.

Most of the process of translating python to R was relatively uninteresting (slicing and dicing data frames is just part of data cleaning), so I won't detail them here. However, there was one part that was particularly interesting---the conversion of a python class object to R. In fact, this was actually the key part of the whole process of getting a working (and "correct") pitch control model.

<!-- I thought it would be a good testing ground for porting python code to R code in a "native" R fashion, with the added challenge of [object-orientated programming (OOP)](https://en.wikipedia.org/wiki/Object-oriented_programming). -->

## Implementation

Below is a heavily stripped down version of Laurie's code, showing the "essence" of what we need to replicate. [^1] I'm using ellipses (`<...>`) in the python code to indicate where code has been removed.

[^1]: If you actually browse Laurie's code, you'll notice that I've changed some of the names of these functions, e.g. `tti()` here instead of `simple_time_to_intercept()` there, `tracking_df` instead of `team` there. Don't worry about that. I just wanted to make things as comparable as possible for the diligent reader, and I tried to make variable names that were either (or both) more succinct or more clear.

Let's make some notes and come back to these as we develop our R class.

1. We need a unique identifier: `player_id`. This is really just a "best practice" thing for object-oriented programming and makes sense given our context. For a sport, a unique identifier could just be the player's name, a combination of the team name and the player jersey number, a league unique identifier, etc.

2. A single-row data frame `frame` is passed to several of the methods, including the constructor `__init__`. This single row data frame is sourced from a much larger `tracking` data frame, with rows for every 0.04 second time interval in the game. (Each interval is called a "frame".)

3. The python code stores both the player's `position` and `velocity` as 2x1 arrays. This works well with the unpacking that is done in other places in Laurie's code. 

4. `tti`, short for "time to intercept (the ball)", uses the player's `position` and `velocity` to define the attribute `tti` (not to be confused with the method itself). Thus, `position` and `velocity` should be defined before `tti()` is ever called, as they are done in `__init__`. `tti` need the `position_final` 2x1 array to calculate `tti` which is not known upon instantiation; rather, `tti` can only be properly defined when called to do a specific calculation relating the player's `position` and `velocity` (both defined implicitly in the class, without needing user-specification) with a user-supplied `position_final` pair of x and y values.

5. `p_intercept`, short for "probability to intercept (the ball)" depends on `tti` and an additional parameter `t`, a user-specified value representing how much time is allotted to reach the ball. Like `tti`, `p_intercept` is only "properly" defined when actually doing a calculation on the player's attributes. Unlike `tti`, there is no attribute that in the `player` instance that stores this probability; it's value must be saved in a variable external to the player class.[^1]

[^1]: One might argue that we should be consistent with `tti` and `p_intercept` and store them in the same way---either both as attributes or neither as attributes---given that both are dependent on some user-specified values (`final_position` for `tti` and `t` for `p_intercept`). I'm just showing how it is done in Laurie's code. I think it is simple enough as is and there is no functional reason why we must change the implementation.


```{python player-python, include=T, echo=F, eval=F}
class player(object):
    def __init__(self,player_id,frame):
        self.id = player_id
        <...>
        self.get_position(frame)
        self.get_velocity(frame)
        
    def get_position(self,frame):
        self.position = np.array(frame[self.player_id + 'x', self.player_id + 'y'])
        <...>
        
    def get_velocity(self,frame):
        self.velocity = np.array(frame[self.player_id + 'x_v', self.player_id + 'y_v'])
        <...>
    
    def tti(self,final_position):
        reaction_position = self.position + self.velocity * <...>
        selfget_tti = <...> + np.linalg.norm(final_positon - reaction_position)/<...>
        <...>

    def p_intercept(self,t):
        return <...>/(t - selfget_tti)
      
```

Ok, on to the R code. We'll be using [S3](https://adv-r.hadley.nz/s3.html) and the [`{vctrs}` package](https://vctrs.r-lib.org/) to help create our `player` class. Again, I've omitted details with `<...>` (which actually is a valid token in R[^1])

[^1]: Yes, I know `...` is also a valid token in python, but it's not used as commonly as it is in R and it has very specific functionality.

First, we start with the constructor `new_player()`. 

```{r new_player, include=T, echo=F, eval=F}
new_player <-
  function(player_id = integer(),
           x = double(),
           y = double(),
           x_v = double(),
           y_v = double(),
           ...) {
    vctrs::new_rcrd(
      list(
        player_id = player_id,
        x = x,
        y = y,
        x_v = x,
        y_v = y,
        tti = -1, # dummy value
        ...
      ),
      class = 'player'
    )
  }
```

1. We have the `player_id` in the constructor.

2. We don't pass the data frame `tracking` here. We'll do it in our helper function. We might say that our constructor is "low-level", not intended for the user to call directly.

3. We split the position and velocity vectors into their individual x and y components, resulting in four total variables instead of two. I don't think an unnamed or named vector, nor a list or a matrix, are particularly compelling data types. None natively support unpacking (although R vectors do have some form of "broadcasting" with their recycling behavior.

4. We assign a "dummy" value to `tti` when initializing the class instance. We will have a method to update `tti` based on x and y components of a variable analogous to `final_position` in the python implementation.

5. Like `tti`, we will need a seperate `p_intercept` method to be used to calculate the probablilty of intercepting a ball given a player's position, speed, and the final position of the ball (all fed as inputs to `tti`), as well as the additional user-specified `t`, representing how much time is allotted to reach the ball.


Next, a validator function. It is good practice to check the values used to construct the class. (The python code did not have any validation like this, but I don't think it was ever expected to be extremely robust to any user input.)

```{r validate_player, include=T, echo=F, eval=F}
validate_player <- function(player) {
  vctrs::vec_assert(vctrs::field(player, 'player_id'), integer())
  vctrs::vec_assert(vctrs::field(player, 'x'), double())
  vctrs::vec_assert(vctrs::field(player, 'y'), double())
  vctrs::vec_assert(vctrs::field(player, 'tti'), double())
  # More validation ...
  player
}
```


Finally, a helper `player()` function, which is our "user-facing" function that we expect/want users to use to instantiate objects.


```{r player, include=T, echo=F, eval=F}
player <- 
  function(player_id, frame, tracking, ...) {
    
    player_id <- as.integer(player_id)
    frame <- as.integer(frame)

    assertthat::assert_that(is.data.frame(tracking))
    nms_req <- c('player_id', 'frame', 'x', 'y', 'x_v', 'y_v')
    assertthat::assert_that(all(nms_req %in% names(tracking)))
    
    # `!!` to make sure that we filter using the integer values, not the column itself.
    tracking_filt <- tracking %>% filter(player_id == !!player_id, frame == !!frame)
    assertthat::assert_that(nrow(tracking_filt) == 1L)
    
    player <-
      new_player(
        player_id = player_id,
        x = tracking_filt[['x']],
        y = tracking_filt[['y']],
        x_v = tracking_filt[['x_v']],
        y_v = tracking_filt[['y_v']],
        ...
      )
    player <- validate_player(player)
    player
  }
```

Note that:

+ We do coercion on `player_id` and `frame` to make sure that they are integers instead of doubles. This ensures that the new `player` instance passes our validation.
+ We pass in our entire `tracking` data frame (that has rows for every 0.04 second interval in the game), as well as the `frame` to slice out of it. (`player_id` is also used to filter `tracking`.) This makes it convenient for user to instantiate new `player` objects when operating on the `tracking` data frame. There is no need to extract the singular initial position and velocity components "manually"; instead, the helper function does it for the user.

Let's do one more thing for our player class. Let's create a custom print method. If we weren't using `{vctrs}` and just S3, we would do this by writing a `print.player()` function. However, `{vctrs}` provides a "pretty" header for us auto-magically (that looks like `<player[1]>` if we use it to write our print method.

To take advantage of this functionality, we write a `format.player()` method that will be called by a subclass of the generic  `vctrs::obj_print_data` method[^1] that itself is called whenever we print out an object (whether explicitly with `print` or just by typing the name of the variable representing our `player` instance). We'll add the player's position and velocity components to the print out. Note that this is not required whatsoever, but it can be very helpful for debugging.

[^1]: `vctrs::obj_print_data` that can also handle Unicode easily, if we were to use Unicode characters). Also, it seems to be able to handle extra `NULL`s and `[1]` that may be printed out if we just use `cat` or `print`.


```{r ref.label='player-print', eval=F}
```

Ok, so that is all fine and dandy, but how would we go about instantiating players in a normal workflow? Let's say that we want to calculate the pitch control for a single `frame` in the `tracking` data.

```{r data, include=F, echo=F, eval=T}
# Data comes from post-processed Metrica sample game 2 data. I'm using a single frame here. Coordinates have been transformed to be on Opta's 100x100 unit grid.
.event_id <- 823L
.start_frame <- 53027L
.end_frame <- 53045L
.ball_x_start <- 89.251
.ball_y_start <- 36.112
.ball_x_end <- 91.866
.ball_y_end <- 54.338
# The events data frame has an `end_frame` in the actual data set as well, hence the `start_` prefix for `frame`.
events1 <-
  tibble(
    event_id = .event_id,
    start_frame = .start_frame,
    end_frame = .end_frame,
    start_x = .ball_x_start,
    start_y = .ball_y_start,
    end_x = .ball_x_end,
    end_y = .ball_y_end,
    side = 'away'
  )

# `frame` would already be a column in the data frame in the original data set, but I've just removed it from the tribble (along with `ball_x` and `ball_y`) to make the tribble thinner.
tracking1 <-
  tibble::tribble(
     ~side, ~player_id,     ~x,     ~y,   ~x_v,   ~y_v,
    'home',         1L, 86.403, 57.897,  5.625, -5.861,
    'home',         2L, 90.569, 39.919,  1.429, -2.975,
    'home',         3L, 91.436, 34.291,   1.35,  3.521,
    'home',         4L, 87.993, 22.997,  0.957,  5.107,
    'home',         5L,  79.96, 36.311,  4.036,  1.764,
    'home',         6L,  78.28, 52.395,  3.707, -0.911,
    'home',         7L, 81.707, 25.492,  1.621,  2.239,
    'home',         8L, 72.437, 73.768,  1.921, -0.725,
    'home',         9L, 58.304, 37.277,  0.821, -1.132,
    'home',        10L, 56.848, 51.611,  0.857, -0.843,
    'home',        11L,  97.66, 47.477, -0.293,  0.918,
    'home',        12L,     NA,     NA,     NA,     NA,
    'home',        13L,     NA,     NA,     NA,     NA,
    'home',        14L,     NA,     NA,     NA,     NA,
    'away',        15L, 65.766, 15.929,  2.039,  1.254,
    'away',        16L, 54.231,  34.43,  2.125, -0.729,
    'away',        17L, 52.172, 57.135,  1.232,   -1.1,
    'away',        18L, 53.468, 78.232,  0.461,  -2.15,
    'away',        19L, 83.557, 23.396,  1.368,  4.664,
    'away',        20L, 68.541,  41.98,  2.793,  1.207,
    'away',        21L, 58.819, 58.089,  1.221, -1.139,
    'away',        22L,  75.67, 66.388,  3.482, -0.968,
    'away',        23L, 89.311, 36.268,  1.589,  4.239,
    'away',        24L, 90.368, 54.044,  2.754,  1.468,
    'away',        25L, 20.222, 53.147,  0.125, -0.314,
    'away',        26L,     NA,     NA,     NA,     NA
  ) %>% 
  mutate(frame = .start_frame, ball_x = .ball_x_start, ball_y = .ball_y_start)
```

This is how the `tracking` data frame might look. I've named it `tracking1` here to indicate that it is just one frame in a larger `tracking` data set.

```{r tracking1}
tracking1
```

Let's convert players with id's 10 through 12 (on the home team) to `player` instances and see how they look when printed out.

```{r players-fake, include=T, echo=F, eval=F}
players <-
  10L:12L %>% 
  map(~player(player_id = .x, frame = 53027L, tracking = tracking1))
```

```{r players-real, include=F, echo=T, eval=T}
players <-
  10L:12L %>%
  map(~player(player_id = .x, frame = .frame, tracking = tracking1, events = events1))
```

We still need to implement analogues for the `tti` and `p_intercept` methods in the python `player` class. Starting with `tti`, let's use the getter-setter construct that can be used calculate and store a `tti` value.

```{r tti-1-fake, include=T, echo=F, eval=F}
# Frobenious norm
euclidean_norm <- function(x1, x2, y1, y2) {
  m <- matrix(c(x1, y1)) - matrix(c(x2, y2))
  sqrt(sum(m^2))
}

get_tti.player <- function(player, x2, y2) {
  ri <- 0.7 # in s
  vmax <- 5 # in m/s
  x1 <- vctrs::field(player, 'x') + vctrs::field(player, 'x_v') * ri
  y1 <- vctrs::field(player, 'y') + vctrs::field(player, 'y_v') * ri
  ri + euclidean_norm(x1, x2, y1, y2) / vmax
}
```

```{r tti-2-fake, ref.label='tti-real-show', include=T, echo=F, eval=F}
```

There's a couple of things going on here:

+ The non-suffixed `get_tti` and `set_tti` functions (that call `UseMethod`) are true S3 generics that perform method dispatch, i.e. find the correct method for the object passed to the generic (based on the class of the object). The `get_tti.player` and `set_tti.player` with `.player` "suffix" so that they only work in their defined manners when passed in a `player` instance. (They won't be called with an object that is not of the `player` class.)
+ The ellipses (`...`) in the S3 generic function signatures may be a bit mysterious since they aren't passed explicitly to `UseMethod`. Any non-`player` arguments are captured in the ellipses and passed to whatever method that is called from the generic (e.g. `get_tti.player` method called from the `get_tti` generic).
+ We must use the "strange" syntax `set_tti<-.player` (instead of just `set_tti.player`, which may seem more "natural") in order to update an attribute in an already instantiated class. [^1]
+ We define the function `euclidean_norm()` outside of `get_tti.player` simply because it is not something that is specific to the time to intercept calculation for a player; it can work with any two pairs of x and y coordinates. It's best to separate out logic in functions like this where it makes sense to do so. (It ultimately makes re-factoring and debugging a lot easier.)
+ `ri` and `vmax`, representing a player's reaction time (in seconds) and a player's maximum velocity (in meters per second) are constants defined in the Spearman paper. We could change these if we wanted to, or even make them dynamic (i.e. configurable via other function parameters, or even at instantiation time).

[^1]: [R6](https://adv-r.hadley.nz/r6.html) is probably a better OOP system to use for this whole use case. The capability to update instance attributes is more native to that framework.

To really complete our getter and setter methods for `tti`, we should write methods to handle the case when a non-`player` object is passed to these method. Thee generic `get_tti` and `set_tti` methods will dispatch to these functions if the object passed to them (named `player`) doesn't actually inherit from the `player` class.

```{r tti-2-fake, include=T, echo=F, eval=F}
msg_cls_err <- function(player, f) {
  cls <- class(player)[1]
  sprintf('`%s()` doesn\'t know how to handle class `%s`!', f, cls) 
}

get_tti.default <- function(player, ...) {
  stop(msg_cls_err(player, 'get_tti'), call. = FALSE)
}

set_tti.default <- function(player, ...) {
  stop(msg_cls_err(player, 'get_tti'), call. = FALSE)
}
```

Note that the ellipses in these methods (`...`) actually serve a purpose---they're meant to capture the "extra" parameters (the parameters other than the first one, `player`) that the user may be attempting to pass to `get_tti` (`x2` and `y2`) and `set_tti` (`value`).

Let's see how this looks in action.


```{r players-fake-2, include=T, echo=F, eval=F}
players <-
  8L:10L %>% 
  map(~player(player_id = .x, frame = 53027L, tracking = tracking1))
```

```{r players-real-2, include=F, echo=T, eval=T}
players <-
  8L:10L %>%
  map(~player(player_id = .x, frame = .frame, tracking = tracking1, events = events1))
```

```{r get_tti-real-demo, include=T, echo=F, eval=F}
target_x <- 89
target_y <- 36
for(i in seq_along(players)) {
  value <- get_tti(players[[i]], x2 = target_x, y2 = target_y)
  set_tti(players[[i]]) <- value
}
players
```

Our approach to `p_intercept` is very similar---we define getters and setters, as well as generics for the class (the intended target of method dispatch) and a default class to handle unexpected inputs.

```{r p_intercept-fake, include=T, echo=F, eval=F}
get_p_intercept.player <- function(x, t, ...) {
  # `tti_sigma` is the standard deviation of the sigmoid function that quantifies the uncertainty in player arrival time
  tti_sigma <- 0.45 
  den <- 1 + exp((-base::pi / sqrt(3) / tti_sigma) * (t - vctrs::field(x, 'tti')))
  1 / den
}
```

...

```{r p_intercept-real-ref, ref.label='p_intercept-real', include=T, echo=F, eval=F}
```

## Aside

R's S3 framework is not a formal object-oriented programming framework (https://en.wikipedia.org/wiki/Object-oriented_programming) (not even close really). I didn't state these before, but note the following about S3.
  + It does not have a token to represent the instance of the class like `self` in python.
  + Also, it is not actually necessary to name our constructor to be prefixed with `new_`. This is just a convention that we force upon ourselves to make it more clear what we are doing.
  + We don't even need a constructor function at all to "use" S3. We could do something like `class(var) <- 'player'` to create a a `player` object. Of course, this is lazy and wouldn't work well, so we don't do that!
  
## What we can do with these S3 powers


```{r path_pc, include=F, echo=F, eval=T}
path_pc <- here::here('pc_832.rds')
```
```{r pc-main, include=F, echo=F, eval=!file.exists(path_pc)}
# debugonce(calculate_pc_at_target)
pc <-
  do_calculate_pc_for_event(
    tracking = tracking1,
    events = events1,
    event_id = .event_id
  )
write_rds(pc, path_pc)
```

```{r path_pc, include=F, echo=F, eval=T}
pc <- read_rds(path_pc)
```

```{r pc-viz, include=F, echo=F, eval=T}
pal <- colorRampPalette(c('red', 'white', 'blue'))(10)
viz <-
  pc %>% 
  ggplot() +
  aes(x = x, y = y, z = ppcf_att) +
  .pitch_gg() +
  geom_contour_filled(aes(fill = ..level.., color = ..level..), alpha = 0.5) +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal) +
  guides(fill = FALSE) +
  ggnewscale::new_scale_fill() +
  geom_point(
    data = tracking1,
    inherit.aes = FALSE,
    aes(x = x, y = y, fill = side),
    size = 4,
    color = 'black',
    shape = 21
  ) +
  scale_fill_manual(values = c('home' = 'red', 'away' = 'blue')) +
  geom_point(
    data = events1,
    inherit.aes = FALSE,
    aes(x = start_x, y = start_y),
    size = 3,
    fill = 'yellow',
    color = 'black',
    shape = 21
  )
viz
```
