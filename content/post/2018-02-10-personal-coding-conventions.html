---
title: Personal Coding Conventions
date: "2018-02-10"
slug: personal-coding-conventions
categories: []
tags:
  - r
  - tidyverse
  - coding
banner: "img/personal-coding-conventions/tidyverse-storybench.png"
---



<p>As a person who’s worked with various programming languages over time, I have become interested in the nuances and overlaps among languages. In particular, concepts related to code syntax and organization–everything from technical concepts such as lexical scoping, to more broad concepts such as importing and naming data–really fascinate me. Organization “enthusiasts” like me truly appreciate software/applications that follow consistent norms.</p>
<p>In the R community, the <code>tidyverse</code> ecosystem has become extremely popular because it implements a consistent, intuitive framework that is, consequently, easy to learn. Even aside from the <code>tidyverse</code>, <code>R</code>’s system for package development, documentation, etc. has strong community-wide standards. <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> In all, there’s something magical about R’s framework that has made it my favorite language to use.</p>
<p>While I tend to follow most of the R community’s “best practices”, there are certain “traditional” or well-agreed upon aspects of <code>R</code> programming where I knowingly deviate from the norm. {^fn_deviate] I think spelling out exactly why I follow the norm on some fronts and not on others is a good exercise in self-understanding, if not just a fun exercise in seeing how many people disagree with me.</p>
<div id="setup" class="section level2">
<h2>Setup</h2>
<ul>
<li>Use quotes (i.e standard evaluation) when importing a package.</li>
</ul>
<pre class="r"><code>library(&quot;dplyr&quot;)
# instead of
library(dplyr)</code></pre>
<p>I believe most people use the non-standard evaluation (NSE) approach, but I like not having to use NSE when it is not really intended to be used as the primary means of invoking a function. (Note that with some packages, such as <code>dplyr</code>, NSE <strong>is</strong> intended to be the primary means of working with variables and functions. In that case, I would not go out of my way to invoke standard evaluation methods.)</p>
<ul>
<li>Import tidyverse packages explicitly instead of importing the <code>tidyverse</code> package itself.</li>
</ul>
<pre class="r"><code>library(&quot;dplyr&quot;)
library(&quot;stringr&quot;)
# instead of 
library(&quot;tidyverse&quot;)</code></pre>
<p>Again, I think I’m probably in the minority on this one (although most people may not even have an opinion on which method is “best”). One can argue that the whole point of bundling the six or so packages that get loaded with <code>library(&quot;tidyverse&quot;)</code> is to “abstract away” having to think about what packages will be necessary for a specific analysis.</p>
<ul>
<li>Do not import a package if it is only being used once or twice. Instead, use the <code>package::function</code> notation.</li>
</ul>
<pre class="r"><code>iris_cleaned &lt;- janitor::clean_names(iris)
# instead of
library(&quot;janitor&quot;)
iris_cleaned &lt;- clean_names(iris)
# ... Then go on to not use janitor again.</code></pre>
<p>Additionally, I may sometimes use the <code>package::function</code> notation even after importing a package if the function name might be confused with a variable name. For example, I might specify <code>lubridate::year()</code> even after calling <code>library(&quot;lubridate&quot;)</code> because <code>year</code> might seem like a verb. (There’s more on that in another section.)</p>
<p>I’m not really sure if there is a general consensus or not on this matter.</p>
<ul>
<li>Favor <code>sprintf()</code> over <code>paste()</code> (or another similar function) if inserting numerics or strings in some kinds of “boiler-plate” string.</li>
</ul>
<p>I think <code>sprintf()</code> offers slightly better “find-and-replace” syntax, which can be useful when re-using code or even when debugging. Also, I think that it makes the underlying string more readable in the case that there are a lot of variables to substitute in to the string. Nonetheless, my justification in this matter is not unwavering–one can argue that <code>paste()</code> has the advantage of more clarity depending on the length of the boiler-plate string and the number of variables to be inserted. (In fact, I often find myself switching among <code>sprintf()</code>, <code>paste()</code>, <code>paste0()</code>, and <code>stringr::str_c()</code> with no real discretion, so I can by hypocritical on this matter.)</p>
<pre class="r"><code>person &lt;- &quot;Tony&quot;
sprintf(&quot;%s is a wonderful person.&quot;, person)
# is not really any easier or more explicit than
paste(person, &quot;is a wonderful person.&quot;)

# but for a case like this
team_1 &lt;- &quot;Yankees&quot;
team_2 &lt;- &quot;Red Sox&quot;
score_1 &lt;- 3
score_2 &lt;- 4

sprintf(&quot;The %s defeated the %s by a score of %0.f to %0.f.&quot;, team_1, team_2, score_1, score_2)
# is probably better than 
paste(&quot;The&quot;, team_1, &quot;defeated the&quot;, team_2, &quot;a score of &quot;, score_1, &quot;to&quot;, score_2, &quot;.&quot;)</code></pre>
<ul>
<li>Favor <code>stringr</code> functions over their base R equivalents (i.e. <code>gsub</code>, <code>grep</code>, etc.).</li>
</ul>
<p>My behavior in this matter is probably not all that controversial, but I just wanted to make a note of it because I sometimes catch myself using functions like <code>gsub()</code> and <code>grep()</code> in “tidy” pipelines, only to realize that a <code>str_replace()</code> or <code>str_detect()</code> would save me some effort because I don’t have to use a <code>.</code> to anonymously specify the <code>x</code>/<code>string</code> argument. Nonetheless, I have found that using the <code>stringr</code> functions is not necessarily second nature for me because the base R methods shown in many <a href="www.stackoverflow.com">Stack Overflow</a> have ingrained in me non-<code>tidyverse</code> style. (I should be clear–these other techniques are not “bad” or “incorrect” in any way.)</p>
</div>
<div id="naming" class="section level2">
<h2>Naming</h2>
<div id="files-and-folders" class="section level3">
<h3>Files and Folders</h3>
<p>For naming files and folders, <a href="http://www2.stat.duke.edu/~rcs46/lectures_2015/01-markdown-git/slides/naming-slides/naming-slides.pdf">Jenny Bryan’s informative presentation “Naming Things”</a> is a must-read. I do my best to follow the principles she outlines, while also adding in some of my own “flair”.</p>
<ul>
<li>Use “-” as a separator in file names to distinguish different components (e.g. <code>...scrape-[website]-...</code>. Otherwise, use an underscore “_&quot; as a separator for words that make up a single topic/entity/component (e.g. <code>...-new_zealand-...</code>)</li>
</ul>
<p>I don’t think my choices in this matter are too controversial.</p>
<ul>
<li>Add a numeric prefix for files that are to be executed in a pre-defined order.</li>
</ul>
<pre><code>01-scrape.R
02-process.R
03-analyze.R
04-report.R</code></pre>
<p>I don’t think my convention is unusual here–there is no conflict with Jenny’s principles.</p>
<p>Notably, I like to add a “main” file, i.e. <code>00-main.R</code>, that sources each of the files in a workflow. Something like GNU Make could also be used, but I like to stick with R tools exclusively. In that case, an R package like <code>remake</code> or <code>drake</code> could be used, but typically my project workflow is not so complex that it necessitates the added functionality that these packages present. Jenny discusses these things in her <a href="http://stat545.com/automation00_index.html"><em>All the Automation Things</em> Topics page</a> Topics page for her class.</p>
<p>Sometimes my project has a “configuration”, i.e. <code>config.R</code> or “functions” <code>functions-analyze.R</code> file that might need to be “sourced” at the beginning of a workflow. I tend to not added numeric prefixes to these files, and I source them in at the beginning of my “main” script.</p>
<ul>
<li>Add numbers for file suffixes, i.e. <code>-v01</code>, <code>-v02</code>, etc., for versioning.</li>
</ul>
<p>This practice of mine is probably atypical. I realize that this is not really necessary if using git or some other version control service, but I have a difficult time completely deleting a file that I am not 100% sure I will never need to look back at. (I generally oppose “hoarding” of things in this manner, but some habits are hard to break).) In my opinion, keeping the file is simply easier than restoring previous snapshots in a git life cycle. Once I’m completely convinced that I no longer have use for an “old” file, then I delete it.</p>
</div>
<div id="functions" class="section level3">
<h3>Functions</h3>
<p>For functions, I do my best to implement the principles outlined in the <a href="http://r4ds.had.co.nz/functions.html">Functions chapter of the R for Data Science e-book</a>. The notion of using verbs for function names (unless the function is so simple that a noun might be more appropriate) makes a lot of sense to me.</p>
<p>Perhaps the reader might find it interesting that I like to use the verb prefix <code>compute_</code> for functions that use <code>dplyr</code> functions in a piped action simply because it is not extremely common and, consequently, not likely to interfere with an existing function name from an imported package. I think my logic on this matter is in tune with general practices–many packages nowadays use package-specific prefixes for their functions in order to distinguish them (e.g. the <code>str_</code> prefix for <code>stringr</code> functions).</p>
<p>Additionally, sometimes I’ll use the simple verb prefix <code>get_</code> (a la the <code>get</code> and <code>set</code> methods of an object class in an object-oriented programming framework) if the function is fairly simple and there is no other intuitive name to use.</p>
</div>
<div id="variables" class="section level3">
<h3>Variables</h3>
<p>I think, in general, my conventions with variables are “acceptable”. Personally, I implement “snake case” for my variable names, although I have no qualms with those who use some other convention (e.g. “Camel Case”) as long as they are consistent. Interestingly, I went through a phase with R programming where I implemented a form of the Visual Basic style of prefixing variable names with the class type of the variable (i.e. <code>strVariable</code> for a string, <code>intVariable</code> for an integer, etc.). <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> I was prefixing my character variables with <code>ch_</code>, data-like variables (i.e. <code>data.frame</code>/<code>matrix</code> with <code>d_</code>, etc.). This practice is probably not all too abhorrent, but I think its more verbose than is necessary, and goes against the original inspiration for <code>R</code>, a language created by statisticians in order to make scientific work more natural for those with little to no experience with computer science.</p>
<div id="variables-for-files-and-folders" class="section level4">
<h4>Variables for Files and Folders</h4>
<p>I tend to break up the names of files into the following components:</p>
<ul>
<li><code>dir</code>: Directory. i.e. what would be returned by <code>gsub(basename(.), &quot;&quot;, .)</code></li>
<li><code>filename</code>: Name of the file, without the directory or extension. i.e. what would be returned by <code>basename(.)</code>.</li>
<li><code>ext</code>: File extension, without the “.”. i.e. What would be returned by <code>tools::file_ext(.)</code>.</li>
</ul>
<p>When combining these three components, I name the variable <code>filepath</code> (using the OS-agnostic <code>file.path()</code> function). Perhaps the more traditional name for such a thing is simply <code>path</code>, but I tend to think that that term is a bit ambiguous.</p>
<pre class="r"><code># Should be a relative path!
dir &lt;- &quot;/path/to/file/&quot;
filename &lt;- &quot;mysupercoolfile&quot;
ext &lt;- &quot;txt&quot;
filepath &lt;- file.path(dir, paste0(filename, &quot;.&quot;, ext))
# Don&#39;t care if an extra forward-slash is added here. It will still work.
filepath</code></pre>
<pre><code>## [1] &quot;/path/to/file//mysupercoolfile.txt&quot;</code></pre>
</div>
<div id="variables-for-dates" class="section level4">
<h4>Variables for Dates</h4>
<p>Because I often work with dates, I have an opinion on naming date-related variables.</p>
<ul>
<li>I like to use <code>yyyymmdd</code> (as opposed to something maybe more intuitive like <code>date</code> or <code>ymd</code>) to refer to a date in the ISO 8601 international standard format (i.e. “2017-03-14” for March 3, 2017).</li>
</ul>
<p>I feel that this format is more explicit and stands out. Similarly, if assigning a number for a year, month, or day, I like to use <code>yyyy</code>, <code>mm</code>, and <code>dd</code> respectively (even if the month or day is a single digit). Others may reason to use <code>year</code>, <code>month</code>, and <code>day</code>, but these names conflict directly with functions in the <code>lubridate</code> package (which I often use for converting numbers representing some kind of time/date). The very short <code>y</code>, <code>m</code>, and <code>d</code> might be another option, but I think each can be can be extremely ambiguous. Is <code>d</code> a day or date? Or data? Is <code>m</code> a month or minute? Is <code>y</code> a year or the response variable in a regression model?</p>
<p>Likewise, my logic advocating the use of <code>yyyymmdd</code> for dates explains my preference for <code>hhmmss</code> for time variables (and <code>hh</code>, <code>mm</code>, <code>ss</code> for individual components of time-related variables).</p>
</div>
<div id="other-objects" class="section level4">
<h4>Other Objects</h4>
<ul>
<li>I prefer to use <code>colname</code> instead of <code>col_name</code> when referencing the <strong>name</strong> of a column in a <code>data.frame</code>/<code>matrix</code>. Since I don’t think <code>col</code> (for column) and <code>name</code> really represent separate entities, I don’t think it’s best to separate them with an underscore. (This convention also explains my preference for <code>filename</code> instead of <code>file_name</code>, as well as <code>filepath</code> instead of <code>file_path</code>.)</li>
</ul>
<p>My stance on this matter might be “out of sync” with the <code>tidyverse</code> mantra. Note that the <code>readr</code> package uses <code>col_names</code> as a parameter.</p>
<ul>
<li>I prefer <code>col</code> instead of <code>var</code> when referencing the <strong>values</strong> in a <code>data.frame</code>/<code>matrix</code>. <code>var</code> can be ambiguous. (Is it a variable in a formula?)</li>
</ul>
<p>I think I’ve seen someone high-up in the R community (Hadley?) mention that they prefer <code>col</code> over <code>var</code> as well, so maybe my practice is “advisable”, if not the norm.</p>
<ul>
<li>I prefer <code>data</code> as the name of the data parameter in a function (assuming that the operation is being performed on a <code>data.frame</code>), as opposed to <code>df</code>,<code>dat</code>, or <code>d</code>. In the case of a function that operates on columns/rows in a <code>data.frame</code>/<code>matrix</code>, I prefer the name <code>x</code>.</li>
</ul>
<p>I think there’s probably a wide range of styles that people have regarding this specific matter, especially the <code>data</code> parameter.</p>
<ul>
<li><p>I try to truncate longer names or actions to 3 or 4 letters. For example, For example, I often use <code>proc</code> instead of <code>processed</code> to indicate that a data object has been transformed in some manner. (In this example, <code>proc</code> would be appended on the name of the input variable (i.e. <code>data_proc</code> if the original variable is <code>data</code>.) Some of my other “go-to”’s include <code>tidy</code> and <code>summ</code> (instead of <code>summarized</code>). Notably, I like to pair <code>trn</code> and <code>tst</code> when working with <code>train</code>ing and <code>test</code>ing sets for machine learning.</p></li>
<li><p>I like to use <code>out</code> for the output variable of a function, irregardless of what the function does (assuming that there are more than a single action in the function, which would require assignment to a variable).</p></li>
</ul>
<p>I think this is fairly common. In fact, I think I picked up this convention when studying other people’s package code.</p>
<ul>
<li>I like to end variables with the “s” suffix when I know that it is a vector. For example, I might use <code>yyyymmdds</code> for a vector of dates.</li>
</ul>
<pre class="r"><code>yyyymmdds &lt;- c(as.Date(&quot;2018-01-01&quot;), as.Date(&quot;2018-02-01&quot;))</code></pre>
<p>This technique can sometimes result in awkward names, which makes me think that most people would be against it. (Perhaps the more likely case is that most people would see the difference as trivial and ask me why I’m thinking so hard about this anyways.)</p>
</div>
</div>
</div>
<div id="projects-and-workflow" class="section level2">
<h2>Projects and Workflow</h2>
<p>I draw heavy inspiration on my format of a project skeleton from the ideas laid out in <a href="https://nicercode.github.io/blog/2013-04-05-project/">Nice R’s blog post on projects</a> and in <a href="http://www.carlboettiger.info/2012/05/06/research-workflow.html">Carl Boettiger’s description of his workflow</a>.</p>
<ul>
<li>For project skeleton, emulate the structure of an R package as closely as possible.</li>
</ul>
<p>To be explicit, my projects tend to look like this.</p>
<pre><code>[project_name]/
|--data/
|--data-raw/
|--docs/
|--figs/
|--output/
|--R/</code></pre>
<p>A short explanation of each: + <code>data/</code>: Data created from scripts (e.g. a web scraper) that are <strong>not</strong> intended to be shared as part of the project’s output. Preferably stored in an R data format (e.g. .rds file). + <code>data-raw/</code>: Manually-collected data. Probably saved as a .csv or .xlsx file. Appropriate location for SQL files and output if a database connection (i.e. with a company/enterprise database) cannot be made directly through R. + <code>docs/</code>: Documentation of the project. Preferably RMarkdown or Markdown file(s). + <code>figs/</code>: Ad-hoc visualizations created interactively that are <strong>not</strong> designated for the project’s output. + <code>output/</code>: Deliverables. Preferably RMarkdown files or files <code>knitted</code> from RMarkdown. Possibly includes nested <code>data</code> or <code>figs</code> folders. + <code>R/</code>: R code. .R files that function primarily as scripts or host a set of functions that are “sourced” into a script file are appropriate.</p>
<p>(See Hadley Wickham’s book on <a href="http://r-pkgs.had.co.nz/"><em>R Packages</em></a> for more explanation.)</p>
<p>Probably the most significant difference between my structure and that of an R package is the <code>output/</code> folder (which might be considered the analogue of a <code>vignettes/</code> folder in an R package).</p>
<p>Regarding project documentation, I prefer the <code>docs/</code> name for the documentation folder, as opposed to the R package standard of <code>man/</code>. In my opinion, <code>docs/</code> is more appropriate because it seems to be the standard name for a folder hosting extensive documentation of a package (as opposed to <code>man/</code>, which is for package functions). (Additionally, I should note that the <code>pkgdown</code> R package for creating a website for an R package and its documentation generates a <code>docs/</code> folder.)</p>
<p>Finally, in compliance with standard R package development, one should add folders for <code>src/</code> and <code>tests/</code> for C code and testing scripts. (I personally have never written C code or tests for my projects.)</p>
<ul>
<li>Create an <code>old/</code> folder in the same location that a no-longer-used file was previously used.</li>
</ul>
<p>This practice of mine goes hand-in-hand with my “manual” versioning of files. When I begin using a newer version of a script, I’ll typically put the previous version(s) in an <code>old/</code> folder.</p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>In general, Hadley Wickham and Jenny Bryan are the “go-to” knowledge resources in the <code>R</code> community on all things related to <code>R</code> programming style, practices, etc.</p>
<ul>
<li><p>Jenny’s Class pages <a href="https://www.stat.ubc.ca/~jenny/STAT545A/#stat-545a-exploratory-data-analysis">here</a> and here <a href="http://stat545.com/index.html">here</a>. <a href="https://www.stat.ubc.ca/~jenny/STAT545A/block19_codeFormattingOrganization.html">This page on code formatting</a> is a must-bookmark.</p></li>
<li><p>Hadley’s <a href="http://vita.had.co.nz/papers/tidy-data.html">original <em>Tidy data</em> paper</a>, <a href="http://r4ds.had.co.nz/"><em>R for Data Science</em> book</a> (co-authored), <a href="http://style.tidyverse.org/">“Tidyverse Style Guide”</a>, and <a href="https://cran.r-project.org/web/packages/tidyverse/vignettes/manifesto.html">“Tidy Tools Manifesto”</a>.</p></li>
</ul>
<p>Of course, these resources represent only a very small subset of amazing resources out there. I know I could go on for days reading about style, syntax, etc., but maybe that’s just me. <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Of course, other programming languages/communities have their own sets of standards that deserve merit.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Note that Camel Case is the preferred style amongst the Visual Basic community.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>If you enjoy this topic, then you probably enjoy classic software-related debates such as <a href="https://stackoverflow.blog/2017/06/15/developers-use-spaces-make-money-use-tabs/">“spaces vs. tabs”</a> and <a href="https://www.datacamp.com/community/tutorials/r-or-python-for-data-analysis">“R vs. python”</a>.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
