---
title: Dealing with Interval Data and the nycflights13 package using R, Part 2
date: "2018-02-19"
slug: interval-data-nycflights13-part-2
categories: []
tags:
  - r
  - dplyr
  - nycflights13
  - functions
banner: "img/interval-data-nycflights13-part-2/datetimes-arithmetic.png"
---



<p>In this post, I’ll continue my discussion of working with regularly sampled interval data using R. (See my previous post for some insight regarding minute data.) The discussion here is focused more so on function design.</p>
<div id="daily-data" class="section level2">
<h2>Daily Data</h2>
<p>When I’ve worked with daily data, I’ve found that the .csv files tend to be much larger than those for data sampled on a minute basis (as a consequence of each file holding data for sub-daily intervals). In these cases, I find that I need to perform the “processing” actions for each file’s data immediately after extracting the daily data because collecting data for all desired days (and performing computations afterwards) would overload my R session.</p>
<p>Developing functions for importing and manipulating “singular” data that is later grouped with other “singular” data can be interesting. Nonetheless, even despite the pecularities of the situation, I do my best to follow software design “best practices” in creating function–I work with a small data set and verify that the expected result is achieved before applying the function to a larger set of data (In this context, this means that I’ll work with one file while developing my core functions.) Sometimes I’ll build in different “capabilities” in these functions –in order to handle unique cases or to experiment with a different processed format– and have the function return a named list of results. This can be useful if I am working on a separate function, for which I may need the input data to be in different formats given a certain condition, or need multiple elements of the output list.</p>
<p>After verifying that I the functions work properly on the hand-picked data, I’ll write one or two “wrapper” functions to iterate over larger temporal periods (i.e. months or years). Although I’ve tried to transition to using <code>purrr</code> functions for all of my iteration needs, I still find myself using loops as a “crutch” since I’ve been using them since I first started programming. <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>To make things a bit more complicated, I’ve had at least one case where I’ve needed to extract data from different kinds of files in the same folders. In this case, I’ve re-factored functions (such as for constructing file paths) to handle the different cases without needing to write a lot more code. The re-factored functions are converted to “core” functions, which are then called by “wrapper” or “API” functions specific for each data type. <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<div id="an-example" class="section level3">
<h3>An Example</h3>
<p>To make all of this discussion relatable, let me provide an example of some of these concepts together. As with my previous write-up, I’ll use the <code>nycflight13</code> data set; however, in order to demonstrate the usefulness of core and wrapper functions, I’ll work with both the <code>flights</code> and <code>weather</code> data sets in this package.</p>
<div class="figure">
<img src="/img/interval-data-nycflights13-part-2/relational-nycflights.png" />

</div>
<p>To begin, I create daily files for each “type” of data (<code>flights</code> and <code>weather</code>). Each daily file is stored in a day-specific folder, which is nested in a month-specific folder, which, in turn, is nested in a year-specific folder.</p>
<pre><code>2013
|_2013-01/
  |_2013-01-01/
    |_flight.csv
    |_weather.csv
  |_2013-01-02/
    |_flight.csv
    |_weather.csv  
  .
  .
  .
|_2013-02/
.
.
.
|_2013-12/</code></pre>
<p>To reduce the amount of data for this example, I’ll work only with data from the first two months of 2013. See the following (somewhat non-robust) code for my implementation of this setup. (My focus is on the subsequent code for extracting and processing the data from these files.)</p>
<pre class="r"><code># A helper funciton for filtering.
filter_nycflights_data &lt;- function(data, origin_filter) {
  data %&gt;%
    filter(month %in% mm_filter)
}

# Creating the data to export.
mm_filter &lt;- c(1:2)
flights_export &lt;-
  nycflights13::flights %&gt;%
  filter_nycflights_data(origin_filter = origin_filter, mm_filter = mm_filter)
weather_export &lt;-
  nycflights13::weather %&gt;% 
  filter_nycflights_data(origin_filter = origin_filter, mm_filter = mm_filter)

# Two helper functions for exporting.
create_dir &lt;- function(dir) {
  if(!dir.exists(dir))
    dir.create(dir)
}

# NOTE: This function is not robust! It assumes that there are `year`, `month`, and `day` columns.
add_yyyymmdd &lt;- function(data) {
  data %&gt;% 
    mutate(yyyymmdd = lubridate::ymd(sprintf(&quot;%04.0f-%02.0f-%02.0f&quot;, year, month, day)))
}

# The main export function.
library(&quot;readr&quot;)
export_files &lt;-
  function(data,
           filename_base,
           dir_base = &quot;data&quot;,
           ext = &quot;csv&quot;) {
    data &lt;- data %&gt;% add_yyyymmdd()
    yyyymmdds &lt;-
      data %&gt;% 
      distinct(yyyymmdd) %&gt;%
      arrange(yyyymmdd) %&gt;%
      pull(yyyymmdd)
    
    i &lt;- 1
    while (i &lt;= length(yyyymmdds)) {
      yyyymmdd_i &lt;- yyyymmdds[i]
      data_i &lt;- data %&gt;% filter(yyyymmdd == yyyymmdd_i)
      
      yyyymm &lt;- strftime(yyyymmdd_i, &quot;%Y-%m&quot;)
      dir_yyyymm &lt;- file.path(dir_base, yyyymm)
      dir_yyyymmdd_i &lt;- file.path(dir_yyyymm, yyyymmdd_i)
      filepath_i &lt;-
        file.path(dir_yyyymmdd_i, paste0(filename_base, &quot;.&quot;, ext))
      
      create_dir(dir_base)
      create_dir(dir_yyyymm)
      create_dir(dir_yyyymmdd_i)
      
      readr::write_csv(data_i, path = filepath_i)
      i &lt;- i + 1
    }
  }

# Finally, using the main export function.
export_files(flights_export, filename_base = &quot;flights&quot;)
export_files(weather_export, filename_base = &quot;weather&quot;)</code></pre>
<p>With the setup out of the way, we can start to look at my approach for importing and manipulating data from these files.</p>
<p>First, I would write a core function for constructing the file paths (<code>get_type_filepaths_bymonth</code>). In this case, I’ve decided that the year (<code>yyyy</code>) and month (<code>mm</code>) are to be passed in as inputs (in addition to the base directory (<code>dir_base</code>) in which to look for files, as well as a regular expression (<code>rgx_filepath</code>) to use for identifying a file by name. This function is set up to “calculate” the names all of the individual day files within a given month’s file.</p>
<p>I could have reasonably decided to make this function more “granular” by making it capable of only identifying a single day file; or, conversely, I could have made it less granular by making it capable of extracting all monthly and daily files for an entire year. Nonetheless, my design choice here is based on a subjective judgement that months is a good compromise–single days is probably inefficient if using this function in a long loop iterating over all days across multiple years, and whole years does not provide much flexibility in the case that there are sporadic missing days or if only looping over several months in a single year. <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<p>In addition to the core function, I’ve written two wrapper functions (<code>get_flights_filepaths_bymonth</code>) and (<code>get_weather_filepaths_bymonth</code>) to work specifically with each “type” of data that I’ll need to import from daily files. As we’ll see later, this kind of function hierarchy allows a singular, higher-level function for importing and processing data to be used for either data type (<code>flight</code> or <code>weather</code>).</p>
<p>As an alternative to the wrapper functions, I might pass the type directly as a parameter in this function. While this might be fine when there are two options, I think it gets more difficult to manage when there are lots of options. Also, I believe that this kind of design strays away from the general “best practice” of designing functions to “do one thing, and do it well”. <a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<pre class="r"><code># This is the &quot;base&quot; function for importing different types of data 
# from the same daily folders in monthly folders.
# &quot;Core&quot; filepath-constructing function.
get_type_filepaths_bymonth &lt;-
  function(yyyy,
           mm,
           dir_base,
           rgx_filepath) {
    
    # Check that no parameters are missing.
    # Credit for this snippet:
    # https://stackoverflow.com/questions/38758156/r-check-if-any-missing-arguments.
    defined &lt;- ls()
    passed &lt;- names(as.list(match.call())[-1])
    if (any(!defined %in% passed)) {
      stop(paste(&quot;Missing values for&quot;, paste(setdiff(defined, passed), collapse = &quot;, &quot;)), call. = FALSE)
    }

    # Now start keyucting the filepaths.
    dir_ym &lt;-
      file.path(dir_base, sprintf(&quot;%04.0f-%02.0f&quot;, yyyy, mm))

    filepaths &lt;-
      list.files(
        path = dir_ym,
        pattern = rgx_filepath,
        full.names = TRUE,
        recursive = FALSE
      )
    
    # Error handling.
    if(length(filepath) == 0) {
      stop(sprintf(&quot;No filepaths found for month %.0f in year %.0f&quot;, mm, yyyy), call. = FALSE) 
    }

    # NOTE: There might be a case where a day does not have a file for some reason.
    date_ymd &lt;- lubridate::ymd(sprintf(&quot;%04.0f_%02.0f_01&quot;, yyyy, mm))
    dd_inmonth &lt;- as.numeric(lubridate::days_in_month(date_ymd))
    if (length(filepaths) != dd_inmonth) {
      stop(
        sprintf(
          &quot;Number of filepaths %.0f is not equal to number of days in month %.0f in year %.0f.&quot;,
          length(filepaths),
          mm,
          yyyy
        ),
        call. = FALSE
      )
    }
    filepaths
  }

dir_base_valid &lt;- &quot;data&quot;
# &quot;Type-specific&quot; filepath-constructing functions.
get_flights_filepaths_bymonth &lt;-
  function(yyyy,
           mm,
           dir_base = dir_base_valid,
           rgx_filepath = &quot;flights&quot;) {
    get_type_filepaths_bymonth(
      yyyy = yyyy,
      mm = mm,
      dir_base = dir_type,
      rgx_filepath = rgx_filepath
    )
  }


get_weather_filepaths_bymonth &lt;-
  function(yyyy,
           mm,
           dir_base = dir_base_valid
           rgx_filepath = &quot;weather&quot;) {
    get_type_filepaths_bymonth(
      yyyy = yyyy,
      mm = mm,
      dir_base = dir_type,
      rgx_filepath = rgx_filepath
    )
  }</code></pre>
<p>Now, after the functions for constructing a proper file path, I would use the same design idiom for functions to import data. My import functions tend to be “short-and-sweet” because I like to reserve all processing–even something as simple as renaming or dropping columns–for separate functions. (Note that, because I identify the file extension with the file path constructor, I can simply use <code>rio::import()</code> to read in the data, irregardless of the file type.)</p>
<p>One can argue that it is not necessary to have separate functions for file path construction and importing, but I think having clear, axiomatic functions to perform singular actions justifies the distinction.</p>
<pre class="r"><code>library(&quot;rio&quot;)
# &quot;Core&quot; importing function.
import_type_data &lt;-
  function(filepath) {
    if (missing(filepath)) {
      stop(&quot;Missing filepath&quot;, call. = FALSE)
    }
    rio::import(filepath) %&gt;% as_tibble()
  }

# &quot;Type-specific&quot; importing functions.
import_flights_data &lt;- import_type_data
import_weather_data &lt;- import_type_data</code></pre>
<p>After importing the data, it is time to process it. Again, it can pay off to write a generic function that is wrapped by other functions. Notably, as opposed to the functions for file path construction and data import, it is likely that a generic processing function will have less code than the wrapper functions, where action is likely to be highly dependent on the data. The core processing function might only add some kind of identifier for the date in order to help with grouping after all of the data is bound together.</p>
<p>In this example, let’s say that I want to add a time stamp indicating when the data was extracted. (Clearly, this may not be necessary if working with static data such as the data in this example; nonetheless, in a real-world situation, adding a time stamp can be extremely significant for reproducibility and/or auditing purposes.) This can implemented in the core <code>process_type_data()</code> function. <a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> <a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a></p>
<p>Now, let’s say that I need to aggregate over any sub-hourly <code>flights</code> data (i.e. data in the departure time (<code>dep_time</code>) and arrival (<code>arr_time</code>) columns), knowing in advance that my computer will not have enough memory to hold all of the data at the end of all extraction. (Obviously, this is not the case with this example.) This could be implemented in the processing function for the flights data, without needing to write any extra logic in the <code>weather</code> processing function to ignore this action. (Note that the <code>weather</code> data has hourly measurements.)</p>
<p>Also, let’s say that I know in advance that I will only need data for a specific subset of the flights data, such as for only certain destinations (<code>dest</code>). (Note that there are 110 unique destinations.) In addition to aggregating over hourly data, filtering for specific destinations will allow me to avoid memory issues. To implement this functionality, I use a generically-named <code>keys</code> argument (that does not need to be specified). Although the <code>weather</code> function does not use <code>keys</code> for anything, it is passed as a parameter to both wrapper processing functions in order to make both work with an API function that can call either without needing to specify different parameters.</p>
<pre class="r"><code># &quot;Core&quot; processing function.
process_type_data &lt;- function(data) {
  data %&gt;% mutate(wd = lubridate::wday(yyyymmdd))
}

process_flights_data &lt;- function(data, keys = NULL) {
  out &lt;- process_type_data(data)

  out &lt;- 
    out %&gt;% 
    mutate_at(vars(contains(&quot;dep_time$|arr_time$&quot;)), funs(hh = round(. / 100, 0) - 1)) %&gt;% 
    group_by(dep_time_hh %&gt;% 
    summarize_at(vars(contains(&quot;dep|arr&quot;)), funs(mean(., na.rm = TRUE))) 
  # This is &quot;custom&quot; processing for the flight-specific function.
  out &lt;- out %&gt;% select(-minute, -time_hour)
  if (!is.null(keys)) {
    out &lt;- out %&gt;% filter(dest %in% keys)
  }
  out
}

process_weather_data &lt;- function(data, keys = NULL) {
  process_type_data(data = data)
}</code></pre>
<p>Now I can use one main “looping” function to call the wrapper functions for file path construction, data import, and (basic) data processing to extract all daily data for a given month. Note how the <code>type</code> parameter provides the flexibility of extracting either <code>flights</code> or <code>weather</code> data with a single function under my design. The names of the functions are constructed using <code>type</code>, and the functions themselves are invoked with <code>do.call()</code>. <a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a></p>
<pre class="r"><code>types_valid &lt;- c(&quot;flights&quot;, &quot;weather&quot;)
# The main function for a single month.
get_type_data_bymonth &lt;- function(yyyy, mm, type = types_valid, keys = NULL) {
  
  # Create names for functions to be passed to `do.call()` in the main `while` loop.
  type &lt;- match.arg(type)
  func_get_filepaths &lt;- sprintf(&quot;get_%s_data_filepaths_bymonth&quot;, type)
  func_import &lt;- sprintf(&quot;import_%s_data&quot;, type)
  func_process &lt;- sprintf(&quot;process_%s_data&quot;, type)
  
  # Gat all filepath for month.
  filepaths &lt;- do.call(func_get_filepaths, list(yyyy = yyyy, mm = mm))
  data_i_list &lt;- vector(&quot;list&quot;, length(filepaths))
  
  i &lt;- 1
  while (i &lt;= length(filepaths)) {
    
    filepath_i &lt;- filepaths[i]
    message(sprintf(&quot;filepath: %s.&quot;, filepath_i))
    yyyymmdd_i &lt;- filepath_i %&gt;% str_extract(&quot;[0-9]{4}-[0-9]{2}-[0-9]{2}&quot;)
    
    data_i &lt;- do.call(func_import, list(filepath = filepath_i))
    data_i &lt;- do.call(func_process, list(data = data_i, yyyymmdd = yyyymmdd_i, keys = keys))
    
    data_i_list[i] &lt;- list(data_i)
    names(data_i_list[i]) &lt;- yyyymmdd_i
    
    message(sprintf(&quot;Done processing %02.0f.&quot;, i))
    i &lt;- i + 1
  }

  out &lt;- do.call(&quot;rbind&quot;, data_i_list)
  out
}

# Using the main function.
flights_nyc_01 &lt;-
  get_type_data_bymonth(yyyy = 2013, mm = 1L, type = &quot;flights&quot;)
flights_nyc_0102_atllax &lt;-
  get_type_data_bymonth(
    yyyy = 2013,
    mm = 1L,
    type = &quot;flights&quot;,
    keys = c(&quot;ATL&quot;, &quot;LAX&quot;)
  )
weather_nyc_0102 &lt;-
  get_type_data_bymonth(yyyy = 2013, mm = 1L, type = &quot;weather&quot;)</code></pre>
<p>Then, if I need to extract data for multiple months and/or multiple years, writing another function to wrap my monthly function (<code>get_type_data_bymonth()</code>) is fairly straightforward. All I need are loops for years (<code>yyyy</code>) and months (<code>mm</code>).</p>
<pre class="r"><code>types_valid &lt;- c(&quot;flights&quot;, &quot;weather&quot;)
# The main function for multiple years/months.
get_type_data_byyear &lt;-
  function(yyyy,
           mm = seq(1L, 12L, 1L),
           type = types_valid ,
           keys) {
    match.arg(type)
    num_yyyy &lt;- length(yyyy)
    num_mm &lt;- length(mm)
    
    data_list &lt;- vector(&quot;list&quot;, num_yyyy * num_mm)
    y_i &lt;- 1
    while (y_i &lt;= num_yyyy) {
      m_i &lt;- 1
      while (m_i &lt;= num_mm) {
        m_i &lt;- mm[i]
        data_ym &lt;-
          get_type_data_bymonth(
            yyyy = y_i,
            mm = m_i,
            type = type,
            keys = keys
          )
        
        ym_i &lt;- y_i + m_i
        data_list[(ym_i)] &lt;- list(data_ym)
        names(data_ym[ym_i]) &lt;- sprintf(&quot;%04.0f_%02.0f&quot;, y_i, m_i)
        m_i &lt;- m_i + 1
      }
      y_i &lt;- y_i + 1
    }
    do.call(&quot;rbind&quot;, data_list)
  }

# Using the main function.
flights_nyc_0102 &lt;-
  get_type_data_byyear(yyyy = 2013, mm = 1L:2L, type = &quot;flights&quot;)
flights_nyc_0102_atllax &lt;-
  get_type_data_byyear(
    yyyy = 2013,
    mm = 1L:2L,
    type = &quot;flights&quot;,
    keys = c(&quot;ATL&quot;, &quot;LAX&quot;)
  )
weather_nyc_0102 &lt;-
  get_type_data_byyear(yyyy = 2013, mm = 1L:2L, type = &quot;weather&quot;)</code></pre>
<p>With all of the data collected, more detailed data processing (beyond the the basic processing done for each file) can be performed. <a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a></p>
</div>
</div>
<div id="final-thoughts" class="section level2">
<h2>Final Thoughts</h2>
<p>In my experience, writing generic functions that can be wrapped by “type-specific” functions has been helpful in a number of situations, such as with extracting data from daily files. This design pattern reduces code length (in most cases), and, more importantly, enhances the readability and re-usability of the code.</p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>When I do use traditional loops, I nearly always opt for <code>while</code> loops instead of <code>for</code> loops, despite the potential trap of an infinite loop if I forget to write the increment for the index. I believe that <code>while</code> loops are more dynamic for situations where the vector/list being iterated upon is not continuous. Also, I find <code>while</code> loops easier to debug.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>In software design, this kind of idiom is similar to the <a href="https://en.wikipedia.org/wiki/Adapter_pattern">adapter pattern</a> and <a href="https://en.wikipedia.org/wiki/Facade_pattern">facade pattern</a> in object-oriented (OO) programming.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Either way, one could easily adapt this function depending on the use case.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>See <a href="https://martinfowler.com/bliki/FlagArgument.html">this article</a> for a discussion of Boolean arguments used to determine the action of functions.)<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>One must be careful with adding processing action that can be done just as easily on the entire data set after it has been collected. For example, adding a column for the day of the week of a certain date should be done at the end of the entire data extraction process.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Note that reducing any kind of processing of raw data until completely necessary may require some re-factoring after initial development of the processing function, where only a single file’s data is being used to test a subsequent function.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Note that I explicitly set <code>keys = NULL</code> by default in order to avoid a “missing” error when using <code>do.call()</code> with the processing function.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>If one had done some fairly custom processing prior to combining all of the data, then one might need re-extract all of the data again if the processing actions need to be changed at some later point in time.<a href="#fnref8">↩</a></p></li>
</ol>
</div>
